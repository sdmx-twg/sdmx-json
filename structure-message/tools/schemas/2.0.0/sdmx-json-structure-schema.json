{
	"$id":"https://raw.githubusercontent.com/sdmx-twg/sdmx-json/master/structure-message/tools/schemas/2.0.0/sdmx-json-structure-schema.json",
	"$schema":"http://json-schema.org/schema#",
	"description":"SDMX-JSON 2.0.0 Schema for SDMX 3.0.0 structure messages",
	"type":"object",
	"properties":{
		"meta":{
			"description":"A meta object that contains non-standard meta-information and basic technical information about the message, such as when it was prepared and who has sent it. Additional properties such as for 'copyright' information can be added.",
			"type":"object",
			"properties":{
				"schema":{
					"$ref":"#/definitions/uri",
					"description":"Contains the URL to the schema allowing to validate the message. This also allows identifying the version of SDMX-JSON format used in this message. Providing the link to the SDMX-JSON schema is recommended."
				},
				"id":{
					"description":"Unique string assigned by the sender that identifies the message for further references.",
					"type":"string",
					"pattern":"^[A-Za-z0-9_@$-]+$"
				},
				"test":{
					"description":"Test indicates whether the message is for test purposes or not. False for normal messages.",
					"type":"boolean"
				},
				"prepared":{
					"description":"A timestamp indicating when the message was prepared. Values must follow the ISO 8601 syntax for combined dates and times, including time zone.",
					"type":"string",
					"format":"date-time"
				},
				"contentLanguages":{
					"description":"Array of strings containing the identifyer of all languages used anywhere in the message for localized elements, and thus the languages of the intended audience, representaing in an array format the same information than the http Content-Language response header, e.g. \"en, fr-fr\". See IETF Language Tags: https://tools.ietf.org/html/rfc5646#section-2.1. The array's first element indicates the main language used in the message for localized elements. The usage of this property is recommended.",
					"type":"array",
					"minItems":1,
					"uniqueItems":true,
					"items":{
						"type":"string",
						"pattern":"^(?:(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))$|^((?:[a-z]{2,3}(?:(?:-[a-z]{3}){1,3})?)|[a-z]{4}|[a-z]{5,8})(?:-([a-z]{4}))?(?:-([a-z]{2}|[0-9]{3}))?((?:-(?:[0-9a-z]{5,8}|[0-9][0-9a-z]{3}))*)?((?:-[0-9a-wy-z](?:-[0-9a-z]{2,8})+)*)?(-x(?:-[0-9a-z]{1,8})+)?$|^(x(?:-[0-9a-z]{1,8})+)$"
					}
				},
				"name":{
					"$ref":"#/definitions/localisedBestMatchText",
					"description":"Name provides a name for the transmission. Multiple instances allow for parallel language values."
				},
				"names":{
					"$ref":"#/definitions/localisedText",
					"description":"Name provides a name for the transmission. Multiple instances allow for parallel language values."
				},
				"sender":{
					"$ref":"#/definitions/party",
					"description":"Sender is information about the party that is transmitting the message."
				},
				"receivers":{
					"description":"Receiver is information about the part(y/ies) that is/are the intended recipient(s) of the message. This can be useful if the WS requires authentication.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/party"
					}
				},
				"links":{
					"$ref":"#/definitions/links"
				}
			},
			"required":[
				"id",
				"prepared",
				"sender"
			]
		},
		"data":{
			"description":"Data contains the message's “primary data”.",
			"type":"object",
			"properties":{
				"dataStructures":{
					"description":"dataStructures contains a collection of data structure definitions. The data structure definitions may be detailed in full, or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/DataStructureType",
						"description":"DataStructure provides the details of a data structure definition, which is defined as a collection of metadata concepts, their structure and usage when used to collect or disseminate data."
					}
				},
				"metadataStructures":{
					"description":"metadataStructures contains a collection of metadata structure definition descriptions. The metadata structure definitions may be detailed in full, or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/MetadataStructureType",
						"description":"metadataStructure provides the details of a metadata structure definition, which is defined as a collection of metadata concepts, their structure and usage when used to collect or disseminate reference metadata. A metadata structure definition performs several functions: it groups sets of objects into \"targets\" against which reference metadata may be reported. Targets define the structure of the reference metadata \"keys\" which identify specific types of reported metadata, and describe the valid values for populating the keys. Also, metadata structure definitions provide a presentational organization of concepts for reporting purposes. The structure of a reference metadata report is derived from this presentational structure."
					}
				},
				"categorySchemes":{
					"description":"categorySchemes contains a collection of category scheme descriptions. The category schemes may be detailed in full, or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/CategorySchemeType",
						"description":"categoryScheme provides the details of a category scheme, which is the descriptive information for an arrangement or division of categories into groups based on characteristics, which the objects have in common. This provides for a simple, leveled hierarchy or categories."
					}
				},
				"conceptSchemes":{
					"description":"conceptSchemes contains one or more concept schemes, which can be explicitly detailed or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/ConceptSchemeType",
						"description":"conceptScheme provides the details of a concept scheme, which is the descriptive information for an arrangement or division of concepts into groups based on characteristics, which the objects have in common. It contains a collection of concept definitions, that may be arranged in simple hierarchies."
					}
				},
				"codelists":{
					"description":"codelists contains a collection of code list descriptions. The code lists may be detailed in full, or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/CodelistType",
						"description":"codelist provides the details of a codelist, which is defined as a list from which some statistical concepts (coded concepts) take their values."
					}
				},
				"geographicCodelists":{
					"description":"geographicCodelists contains a collection of geographic code list descriptions. The geographic code lists may be detailed in full, or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/GeographicCodelistType",
						"description":"geographicCodelist provides the details of a geographic code list, which comprises a set of GeoFeatureSetCodes, by adding a value in the Code that follows a pattern to represent a geo feature set."
					}
				},
				"geoGridCodelists":{
					"description":"geoGridCodelists contains a collection of geographic grid code list descriptions. The geographic grid code lists may be detailed in full, or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/GeoGridCodelistType",
						"description":"geoGridCodelist provides the details of a geographic grid code list, which comprises a set of GridCodes, which are related to the gridDefinition specified in the GeoGridCodelist."
					}
				},
				"valueLists":{
					"description":"valueLists contains a collection of value list descriptions. The value lists may be detailed in full, or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/ValueListType",
						"description":"valueList provides the details of a value list, which is a closed set of values that can occur for a dimension, measure, or attribute. This may be a simple list of values, or a list of values with names and descriptions (similar to a codelist)."
					}
				},
				"hierarchies":{
					"description":"hierarchies contains a collection of hierarchies, which are hierarchical code list descriptions, which can be explicitly detailed or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/HierarchyType",
						"description":"hierarchy provides the details of a hierarchy, which is defined as an organised collection of codes that may participate in many parent/child relationships with other codes in the list."
					}
				},
				"hierarchyAssociations":{
					"description":"hierarchyAssociations ontains a collection of hierarchy associations. The associations may be detailed in full, or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/HierarchyAssociationType",
						"description":"hierarchyAssociation provides the details of a hiearchy assoication, which associates a hiearchy with an identifiable object in the context of another object."
					}
				},
				"agencySchemes":{
					"description":"agencySchemes contains a collection of agency scheme descriptions.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/AgencySchemeType",
						"description":"agencyScheme provides the details of an agency scheme, in which agencies are described."
					}
				},
				"dataProviderSchemes":{
					"description":"dataProviderSchemes contains a collection of data provider schemes descriptions.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/DataProviderSchemeType",
						"description":"dataProviderScheme provides the details of a data provider scheme, in which data providers are described."
					}
				},
				"dataConsumerSchemes":{
					"description":"dataConsumerSchemes contains a collection of data consumer schemes descriptions.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/DataConsumerSchemeType",
						"description":"dataConsumerScheme provides the details of an data consumer scheme, in which data consumers are described."
					}
				},
				"metadataProviderSchemes":{
					"description":"metadataProviderSchemes contains a collection of metadata provider schemes descriptions.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/MetadataProviderSchemeType",
						"description":"metadataProviderScheme provides the details of an metadata provider scheme, in which metadata providers are described."
					}
				},
				"organisationUnitSchemes":{
					"description":"organisationUnitSchemes contains a collection of organisation unit schemes descriptions.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/OrganisationUnitSchemeType",
						"description":"organisationUnitScheme provides the details of an organisation unit scheme, in which organisation units are described."
					}
				},
				"dataflows":{
					"description":"dataflows contains a collection of data flow descriptions. The data flows may be detailed in full, or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/DataflowType",
						"description":"dataflow provides the details of a data flow, which is defined as the structure of data that will be provided for different reference periods."
					}
				},
				"metadataflows":{
					"description":"metadataflows contains a collection of metadata flow descriptions. The metadata flows may be detailed in full, or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/MetadataflowType",
						"description":"metadataflow provides the details of a metadata flow, which is defined as the structure of reference metadata that will be provided for different reference periods"
					}
				},
				"reportingTaxonomies":{
					"description":"reportingTaxonomies contains a collection of reporting taxonomy descriptions. The reporting taxonomies may be detailed in full, or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/ReportingTaxonomyType",
						"description":"reportingTaxonomy provides the details of a reporting taxonomy, which is a scheme which defines the composition structure of a data report where each component can be described by an independent data or metadata flow definition."
					}
				},
				"provisionAgreements":{
					"description":"provisionAgreements contains a collection of provision agreements. The provision agreements may be detailed in full, or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/ProvisionAgreementType",
						"description":"provisionAgreement provides the details of a provision agreement, which is an agreement for a data provider to report data or reference metadata against a flow."
					}
				},
				"metadataProvisionAgreements":{
					"description":"metadataProvisionAgreements contains a collection of metadata provision agreements. The metadata provision agreements may be detailed in full, or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/MetadataProvisionAgreementType",
						"description":"metadataProvisionAgreement provides the details of a metadata provision agreement, which is an agreement for a metadata provider to report reference metadata against a flow."
					}
				},
				"structureMaps":{
					"description":"structureMaps contains a collection of structure map descriptions. The structure maps may be detailed in full, or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/StructureMapType",
						"description":"StructureMap provides the details of a structure map, which allows allows mapping between data dtructures or dataflows."
					}
				},
				"representationMaps":{
					"description":"representationMaps contains a collection of representation map descriptions. The representation maps may be detailed in full, or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/RepresentationMapType",
						"description":"representationMap provides the details of a representation map, which ..."
					}
				},
				"conceptSchemeMaps":{
					"description":"conceptSchemeMaps contains a collection of concept scheme map descriptions. The concept scheme maps may be detailed in full, or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/ConceptSchemeMapType",
						"description":"conceptSchemeMap provides the details of a concept scheme map, which ..."
					}
				},
				"categorySchemeMaps":{
					"description":"categorySchemeMaps contains a collection of category scheme map descriptions. The category scheme maps may be detailed in full, or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/CategorySchemeMapType",
						"description":"categorySchemeMap provides the details of a category scheme map, which ..."
					}
				},
				"organisationSchemeMaps":{
					"description":"organisationSchemeMaps contains a collection of organisation scheme map descriptions. The organisation scheme maps may be detailed in full, or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/OrganisationSchemeMapType",
						"description":"organisationSchemeMap provides the details of a organisation scheme map, which ..."
					}
				},
				"reportingTaxonomyMaps":{
					"description":"reportingTaxonomyMaps contains a collection of reporting taxonomy map descriptions. The reporting taxonomy maps may be detailed in full, or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/ReportingTaxonomyMapType",
						"description":"reportingTaxonomyMap provides the details of a reporting taxonomy map, which ..."
					}
				},
				"processes":{
					"description":"processes contains a collection of process descriptions. The processes may be detailed in full, or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/ProcessType",
						"description":"process provides the details of a process, which is a scheme which defines or documents the operations performed on data in order to validate data or to derive new information according to a given set of rules. It is not meant to support process automation, but serves as a description of how processes occur. The primary use for this structural mechanism is the attachment of reference metadata regarding statistical processing. This must either contain the full details of the category scheme, or provide a name and identification information and reference the full details from an external structure document or registry service."
					}
				},
				"categorisations":{
					"description":"categorisations contains a collection of structural object categorisations. This container may contain categorisations for many types of objects. The categorisations may be detailed in full, or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/CategorisationType",
						"description":"categorisation allows for the association of an identifiable object to a category, providing for the classifications of the reference identifiable object. This must either contain the full details of the categorisation, or provide a name and identification information and reference the full details from an external structure document or registry service."
					}
				},
				"dataConstraints":{
					"description":"dataConstraints contains one or more data constraint, which can be explicitly detailed or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/DataConstraintType",
						"description":"dataConstraint specifies a sub set of the definition of the allowable or available content of a data set in terms of the content or in terms of the set of key combinations."
					}
				},
				"metadataConstraints":{
					"description":"metadataConstraints contains one or more metadata constraint, which can be explicitly detailed or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/MetadataConstraintType",
						"description":"metadataConstraint specifies a sub set of the definition of the allowable content of a metadata set."
					}
				},
				"customTypeSchemes":{
					"description":"customTypeSchemes contains one or more custom type schemes, which can be explicitly detailed or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/CustomTypeSchemeType",
						"description":"customTypeScheme ..."
					}
				},
				"vtlMappingSchemes":{
					"description":"vtlMappingSchemes contains one or more vtl mapping schemes, which can be explicitly detailed or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/VtlMappingSchemeType",
						"description":"vtlMappingScheme ..."
					}
				},
				"namePersonalisationSchemes":{
					"description":"namePersonalisationSchemes contains one or more name personalisation schemes, which can be explicitly detailed or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/NamePersonalisationSchemeType",
						"description":"namePersonalisationScheme ..."
					}
				},
				"rulesetSchemes":{
					"description":"rulesetSchemes contains one or more ruleset schemes, which can be explicitly detailed or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/RulesetSchemeType",
						"description":"rulesetScheme ..."
					}
				},
				"transformationSchemes":{
					"description":"transformationSchemes contains one or more transformation schemes, which can be explicitly detailed or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/TransformationSchemeType",
						"description":"transformationScheme ..."
					}
				},
				"userDefinedOperatorSchemes":{
					"description":"userDefinedOperatorSchemes contains one or more user defined operator schemes, which can be explicitly detailed or referenced from an external structure document or registry service.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/UserDefinedOperatorSchemeType",
						"description":"userDefinedOperatorScheme ..."
					}
				}
			}
		},
		"errors":{
			"description":"Errors field is an array of error objects. When appropriate provides a list of error messages in addition to RESTful web services HTTP error status codes.",
			"type":"array",
			"items":{
				"description":"Error describes the structure of an error or warning message.",
				"type":"object",
				"properties":{
					"code":{
						"description":"Provides a code number for the error message. Code numbers are defined in the SDMX 2.1 Web Services Guidelines.",
						"type":"number"
					},
					"title":{
						"$ref":"#/definitions/localisedBestMatchText",
						"description":"Title contains the title of the message, in best-match language value. A short, human-readable localised summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization."
					},
					"titles":{
						"$ref":"#/definitions/localisedText",
						"description":"Title contains the title of the message, in parallel language values. A list of short, human-readable localised summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization."
					},
					"detail":{
						"$ref":"#/definitions/localisedBestMatchText",
						"description":"Detail contains the detailed text of the message, in best-match language value. A human-readable localised explanation specific to this occurrence of the problem. Like title, this field’s value can be localized. It is fully customizable by the service providers and should provide enough detail to ease understanding the reasons of the error."
					},
					"details":{
						"$ref":"#/definitions/localisedText",
						"description":"Detail contains the detailed text of the message, in parallel language values. A list of human-readable localised explanations specific to this occurrence of the problem. Like title, this field’s value can be localized. It is fully customizable by the service providers and should provide enough detail to ease understanding the reasons of the error."
					},
					"links":{
						"$ref":"#/definitions/links",
						"description":"Links field is an array of link objects. If appropriate, a collection of links to additional external resources for the error."
					}
				},
				"required":[
					"code"
				]
			}
		}
	},
	"definitions":{
		"party":{
			"description":"Sender contains information about the party that is transmitting the message.",
			"type":"object",
			"properties":{
				"id":{
					"description":"The id holds the identification of the party.",
					"type":"string",
					"pattern":"^[A-Za-z0-9_@$-]+$"
				},
				"name":{
					"description":"Name is a human-readable name of the party.",
					"$ref":"#/definitions/localisedBestMatchText"
				},
				"names":{
					"description":"Name is a human-readable name of the party.",
					"$ref":"#/definitions/localisedText"
				},
				"contacts":{
					"description":"Contact provides contact information for the party in regard to the transmission of the message.",
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/contactType"
					}
				}
			},
			"required":[
				"id"
			]
		},
		"links":{
			"description":"Links field is an array of link objects. If appropriate, a collection of links to additional resources, including external resources.",
			"type":"array",
			"items":{
				"type":"object",
				"properties":{
					"href":{
						"$ref":"#/definitions/uri"
					},
					"rel":{
						"description":"Relationship of the object to the resource. See semantics below. Use 'self' to indicate the urn to the parent object.",
						"anyOf":[
							{
								"type":"string"
							},
							{
								"description":"structure: provides a reference to the data structure or metadata structure definition depending on the context. Other SDMX artefact types can be specified, e.g. dataflow, provisionagreement, etc. For the others please see: https://tools.ietf.org/rfc/rfc5988.txt",
								"type":"string",
								"enum":[
									"agency",
									"agencyscheme",
									"attributedescriptor",
									"alternate",
									"appendix",
									"bookmark",
									"categorisation",
									"category",
									"categoryscheme",
									"categoryschememap",
									"chapter",
									"code",
									"codelist",
									"componentmap",
									"concept",
									"conceptscheme",
									"conceptschememap",
									"constraint",
									"contents",
									"copyright",
									"current",
									"customtype",
									"customtypescheme",
									"dataattribute",
									"dataconstraint",
									"dataconsumer",
									"dataconsumerscheme",
									"dataflow",
									"dataprovider",
									"dataproviderscheme",
									"datastructure",
									"datastructuredefinition",
									"datepatternmap",
									"describedby",
									"dimension",
									"dimensiondescriptor",
									"edit",
									"edit-media",
									"enclosure",
									"epochmap",
									"first",
									"frequencyformatmapping",
									"glossary",
									"groupdimesiondescriptor",
									"help",
									"hierarchicalcode",
									"hierarchy",
									"hierarchyassociation",
									"hub",
									"index",
									"itemschememap",
									"last",
									"latest-version",
									"license",
									"level",
									"measure",
									"measuredescriptor",
									"metadataattribute",
									"metadataconstraint",
									"metadataflow",
									"metadataproviderscheme",
									"metadataprovisionagreement",
									"metadataprovider",
									"metadatastructure",
									"metadatastructuredefinition",
									"namepersonalisation",
									"namepersonalisatinscheme",
									"next",
									"next-archive",
									"organisationschememap",
									"organisationunit",
									"organisationunitscheme",
									"payment",
									"prev",
									"predecessor-version",
									"previous",
									"prev-archive",
									"process",
									"processstep",
									"provisionagreement",
									"related",
									"replies",
									"reportingcategory",
									"reportingtaxonomy",
									"reportingtaxonomymap",
									"metadataattributedescriptor",
									"representatiomap",
									"ruleset",
									"rulesetscheme",
									"section",
									"self",
									"service",
									"start",
									"structure",
									"structuremap",
									"stylesheet",
									"subscription",
									"subsection",
									"successor-version",
									"timedimension",
									"transformation",
									"transformationscheme",
									"transition",
									"userdefinedoperator",
									"userdefinedoperatorscheme",
									"up",
									"valuelist",
									"version-history",
									"via",
									"vtlcodelistmapping",
									"vtlconceptmapping",
									"vtldataflowmapping",
									"vtlmappingscheme",
									"working-copy",
									"working-copy-of"
								]
							}
						]
					},
					"urn":{
						"description":"The urn holds any valid SDMX Registry URN (see SDMX Registry Specification for details).",
						"$ref":"#/definitions/urn"
					},
					"uri":{
						"description":"The uri attribute holds a URI that contains a link to additional information about the resource, such as a web page. This uri is not an SDMX resource.",
						"$ref":"#/definitions/uri"
					},
					"title":{
						"$ref":"#/definitions/localisedBestMatchText"
					},
					"titles":{
						"$ref":"#/definitions/localisedText"
					},
					"type":{
						"description":"A hint about the type of representation returned by the link.",
						"type":"string"
					},
					"hreflang":{
						"description":"The natural language of the external link, the same as used in the HTTP Accept-Language request header.",
						"type":"string",
						"pattern":"^(?:(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))$|^((?:[a-z]{2,3}(?:(?:-[a-z]{3}){1,3})?)|[a-z]{4}|[a-z]{5,8})(?:-([a-z]{4}))?(?:-([a-z]{2}|[0-9]{3}))?((?:-(?:[0-9a-z]{5,8}|[0-9][0-9a-z]{3}))*)?((?:-[0-9a-wy-z](?:-[0-9a-z]{2,8})+)*)?(-x(?:-[0-9a-z]{1,8})+)?$|^(x(?:-[0-9a-z]{1,8})+)$"
					}
				},
				"anyOf":[
					{
						"required":[
							"href",
							"rel"
						]
					},
					{
						"required":[
							"urn",
							"rel"
						]
					}
				]
			}
		},
		"localisedBestMatchText":{
			"type":"string",
			"description":"localisedBestMatchText is a reusable element, used for providing a human-readable best-language-match texts."
		},
		"localisedText":{
			"description":"localisedText provides for a set of language-specific alternates to be provided for any human-readable constructs in the instance. ",
			"type":"object",
			"patternProperties":{
				"^(?:(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))$|^((?:[a-z]{2,3}(?:(?:-[a-z]{3}){1,3})?)|[a-z]{4}|[a-z]{5,8})(?:-([a-z]{4}))?(?:-([a-z]{2}|[0-9]{3}))?((?:-(?:[0-9a-z]{5,8}|[0-9][0-9a-z]{3}))*)?((?:-[0-9a-wy-z](?:-[0-9a-z]{2,8})+)*)?(-x(?:-[0-9a-z]{1,8})+)?$|^(x(?:-[0-9a-z]{1,8})+)$":{
					"type":"string"
				}
			}
		},
		"contactType":{
			"description":"ContactType describes the structure of a contact's details.",
			"type":"object",
			"properties":{
				"id":{
					"$ref":"#/definitions/idType"
				},
				"name":{
					"description":"Name contains a humain-readable name for the contact.",
					"$ref":"#/definitions/localisedBestMatchText"
				},
				"names":{
					"description":"Name contains a humain-readable name for the contact.",
					"$ref":"#/definitions/localisedText"
				},
				"department":{
					"description":"Department is a humain-readable designation of the organisational structure by a linguistic expression, within which the contact person works.",
					"$ref":"#/definitions/localisedBestMatchText"
				},
				"departments":{
					"description":"Department is a humain-readable designation of the organisational structure by a linguistic expression, within which the contact person works.",
					"$ref":"#/definitions/localisedText"
				},
				"role":{
					"description":"Role is the humain-readable responsibility of the contact person with respect to the object for which this person is the contact.",
					"$ref":"#/definitions/localisedBestMatchText"
				},
				"roles":{
					"description":"Role is the humain-readable responsibility of the contact person with respect to the object for which this person is the contact.",
					"$ref":"#/definitions/localisedText"
				},
				"telephones":{
					"type":"array",
					"minItems":1,
					"items":{
						"description":"Telephone holds the telephone number for the contact person.",
						"type":"string"
					}
				},
				"faxes":{
					"type":"array",
					"minItems":1,
					"items":{
						"description":"Fax holds the fax number for the contact person.",
						"type":"string"
					}
				},
				"x400s":{
					"type":"array",
					"minItems":1,
					"items":{
						"description":"X400 holds the X.400 address for the contact person.",
						"type":"string"
					}
				},
				"uris":{
					"type":"array",
					"minItems":1,
					"items":{
						"description":"URI holds an information URL for the contact person.",
						"$ref":"#/definitions/uri"
					}
				},
				"emails":{
					"type":"array",
					"minItems":1,
					"items":{
						"description":"Email holds the email address for the contact person.",
						"type":"string",
						"format":"email"
					}
				}
			}
		},
		"idType":{
			"description":"IDType provides a type which is used for restricting the characters in codes and IDs throughout all SDMX-ML messages. Valid characters include A-Z, a-z, @, 0-9, _, -, $. Regex: [A-Za-z0-9_@$-]+",
			"type":"string",
			"pattern":"^[A-Za-z0-9_@$-]+$"
		},
		"WildcardIDType":{
			"description":"WildcardIDTypeType combines the IDType and WildcardType to allow a reference to either a specific identifier, or to wildcard the identifier in the reference by specifying the '*' value.",
			"anyOf":[
				{
					"$ref":"#/definitions/idType"
				},
				{
					"$ref":"#/definitions/WildcardType"
				}
			]
		},
		"AnnotationType":{
			"description":"AnnotationType provides for non-documentation notes and annotations to be embedded in data and structure messages. It provides optional fields for providing a title, a type description, a URI, and the text of the annotation.",
			"type":"object",
			"properties":{
				"id":{
					"description":"Non-standard identification of an annotation.",
					"type":"string"
				},
				"title":{
					"description":"AnnotationTitle provides a title for the annotation.",
					"type":"string"
				},
				"type":{
					"description":"AnnotationType is used to distinguish between annotations designed to support various uses. The types are not enumerated, as these can be specified by the user or creator of the annotations. The definitions and use of annotation types should be documented by their creator.",
					"type":"string"
				},
				"value":{
					"description":"AnnotationValue holds a string containing the non-localised value text of the annotation.",
					"type":"string"
				},
				"text":{
					"description":"AnnotationText holds a language-specific string containing the text of the annotation.",
					"$ref":"#/definitions/localisedBestMatchText"
				},
				"texts":{
					"description":"AnnotationText holds a language-specific string containing the text of the annotation.",
					"$ref":"#/definitions/localisedText"
				},
				"links":{
					"description":"Links field is an array of link objects. Also used to specify the Annotation URL which points to an external resource which may contain or supplement the annotation (using 'self' as relationship). If a specific behavior is desired, an annotation type should be defined which specifies the use of this field more exactly. If appropriate, a collection of links to additional external resources.",
					"$ref":"#/definitions/links"
				}
			}
		},
		"AnnotationsType":{
			"description":"AnnotationsType is a reusable element the provides for a collection of annotations. It has been made global so that restrictions of types that extend AnnotableType my reference it.",
			"type":"array",
			"minItems":1,
			"items":{
				"$ref":"#/definitions/AnnotationType"
			}
		},
		"AnnotableType":{
			"description":"AnnotableType is an abstract base type used for all annotable artefacts. Any type that provides for annotations should extend this type.",
			"type":"object",
			"properties":{
				"annotations":{
					"$ref":"#/definitions/AnnotationsType"
				}
			}
		},
		"IdentifiableType":{
			"description":"IdentifiableType is an abstract base type for all identifiable objects.",
			"type":"object",
			"allOf":[
				{
					"properties":{
						"id":{
							"$ref":"#/definitions/idType"
						},
						"links":{
							"$ref":"#/definitions/links",
							"description":"Links field is an array of link objects. Also used to specify the URI or the URN to itself. If appropriate, a collection of links to additional external resources."
						}
					}
				},
				{
					"$ref":"#/definitions/AnnotableType"
				}
			]
		},
		"IdentifiableTypeWithNCNameID":{
			"description":"IdentifiableType is an abstract base type for all identifiable objects.",
			"type":"object",
			"allOf":[
				{
					"properties":{
						"id":{
							"$ref":"#/definitions/NCNameIDType"
						},
						"links":{
							"$ref":"#/definitions/links",
							"description":"Links field is an array of link objects. Also used to specify the URI or the URN to itself. If appropriate, a collection of links to additional external resources."
						}
					}
				},
				{
					"$ref":"#/definitions/AnnotableType"
				}
			]
		},
		"NameableType":{
			"description":"NameableType is an abstract base type for all nameable objects.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/IdentifiableType"
				},
				{
					"properties":{
						"name":{
							"$ref":"#/definitions/localisedBestMatchText"
						},
						"names":{
							"$ref":"#/definitions/localisedText"
						},
						"description":{
							"$ref":"#/definitions/localisedBestMatchText"
						},
						"descriptions":{
							"$ref":"#/definitions/localisedText"
						}
					}
				}
			],
			"required":[
				"name"
			]
		},
		"NameableTypeWithNCNameID":{
			"description":"NameableType is an abstract base type for all nameable objects with NCNameID.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/IdentifiableTypeWithNCNameID"
				},
				{
					"properties":{
						"name":{
							"$ref":"#/definitions/localisedBestMatchText"
						},
						"names":{
							"$ref":"#/definitions/localisedText"
						},
						"description":{
							"$ref":"#/definitions/localisedBestMatchText"
						},
						"descriptions":{
							"$ref":"#/definitions/localisedText"
						}
					}
				}
			],
			"required":[
				"name"
			]
		},
		"MaintainableType":{
			"description":"MaintainableType is an abstract base type for all maintainable objects.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/NameableType"
				},
				{
					"properties":{
						"version":{
							"$ref":"#/definitions/VersionType"
						},
						"agencyID":{
							"$ref":"#/definitions/NestedNCNameIDType"
						},
						"isExternalReference":{
							"type":"boolean"
						},
						"validFrom":{
							"type":"string",
							"format":"date-time"
						},
						"validTo":{
							"type":"string",
							"format":"date-time"
						}
					}
				}
			],
			"required":[
				"id",
				"agencyID",
				"name"
			]
		},
		"MaintainableWithoutVersionType":{
			"description":"MaintainableWithoutVersionType is an abstract base type for all maintainable objects without version (and fixed id). For the moment, the version number is fixed to '1.0'",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/AnnotableType"
				},
				{
					"properties":{
						"version":{
							"const":"1.0"
						},
						"agencyID":{
							"$ref":"#/definitions/NestedNCNameIDType"
						},
						"name":{
							"$ref":"#/definitions/localisedBestMatchText"
						},
						"names":{
							"$ref":"#/definitions/localisedText"
						},
						"description":{
							"$ref":"#/definitions/localisedBestMatchText"
						},
						"descriptions":{
							"$ref":"#/definitions/localisedText"
						},
						"isExternalReference":{
							"type":"boolean"
						},
						"validFrom":{
							"type":"string",
							"format":"date-time"
						},
						"validTo":{
							"type":"string",
							"format":"date-time"
						},
						"links":{
							"$ref":"#/definitions/links",
							"description":"Links field is an array of link objects. Also used to specify the URI or the URN to itself. If appropriate, a collection of links to additional external resources."
						}
					}
				}
			],
			"required":[
				"id",
				"agencyID",
				"name"
			]
		},
		"MaintainableTypeWithNCNameID":{
			"description":"MaintainableType is an abstract base type for all maintainable objects with NCNameID.",
			"type":"object",
			"allOf":[
				{
					"properties":{
						"version":{
							"$ref":"#/definitions/VersionType"
						},
						"agencyID":{
							"$ref":"#/definitions/NestedNCNameIDType"
						}
					}
				},
				{
					"$ref":"#/definitions/NameableTypeWithNCNameID"
				},
				{
					"properties":{
						"isExternalReference":{
							"type":"boolean"
						},
						"validFrom":{
							"type":"string",
							"format":"date-time"
						},
						"validTo":{
							"type":"string",
							"format":"date-time"
						}
					}
				}
			],
			"required":[
				"id",
				"agencyID",
				"name"
			]
		},
		"ComponentValueSetType":{
			"description":"ComponentValueSetType defines the structure for providing values for a data attributes, measures, or metadata attributes. If no values are provided, the component is implied to include/excluded from the region in which it is defined, with no regard to the value of the component. Note that for metadata attributes which occur within other metadata attributes, a nested identifier can be provided. For example, a value of CONTACT.ADDRESS.STREET refers to the metadata attribute with the identifier STREET which exists in the ADDRESS metadata attribute in the CONTACT metadata attribute, which is defined at the root of the report structure.",
			"type":"object",
			"properties":{
				"id":{
					"$ref":"#/definitions/NestedNCNameIDType"
				},
				"include":{
					"type":"boolean",
					"description":"The include attribute indicates whether the values provided for the referenced component are to be included are excluded from the region in which they are defined."
				},
				"removePrefix":{
					"type":"boolean",
					"description":"The removePrefix attribute indicates whether codes should keep or not the prefix, as defined in the extension of codelist."
				},
				"timeRange":{
					"$ref":"#/definitions/TimeRangeValueType"
				},
				"values":{
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/SimpleComponentValueType"
					}
				}
			},
			"required":[
				"id"
			],
			"anyOf":[
				{
					
				},
				{
					"required":[
						"timeRange"
					]
				},
				{
					"required":[
						"values"
					]
				}
			],
			"not":{
				"required":[
					"timeRange",
					"values"
				]
			}
		},
		"DataComponentValueSetType":{
			"description":"DataComponentValueSetType defines the structure for providing values for a data attributes, measures, or metadata attributes. If no values are provided, the component is implied to include/excluded from the region in which it is defined, with no regard to the value of the component. Note that for metadata attributes which occur within other metadata attributes, a nested identifier can be provided. For example, a value of CONTACT.ADDRESS.STREET refers to the metadata attribute with the identifier STREET which exists in the ADDRESS metadata attribute in the CONTACT metadata attribute, which is defined at the root of the report structure.",
			"type":"object",
			"properties":{
				"id":{
					"$ref":"#/definitions/NestedNCNameIDType"
				},
				"include":{
					"type":"boolean",
					"description":"The include attribute indicates whether the values provided for the referenced component are to be included are excluded from the region in which they are defined."
				},
				"removePrefix":{
					"type":"boolean",
					"description":"The removePrefix attribute indicates whether codes should keep or not the prefix, as defined in the extension of codelist."
				},
				"timeRange":{
					"$ref":"#/definitions/TimeRangeValueType"
				},
				"values":{
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/DataComponentValueType"
					}
				}
			},
			"required":[
				"id"
			],
			"anyOf":[
				{
					
				},
				{
					"required":[
						"timeRange"
					]
				},
				{
					"required":[
						"values"
					]
				}
			],
			"not":{
				"required":[
					"timeRange",
					"values"
				]
			}
		},
		"BasicComponentDataType":{
			"description":"BasicComponentDataType provides an enumerated list of the types of characters allowed in the dataType attribute for all non-target object components.",
			"type":"string",
			"enum":[
				"String",
				"Alpha",
				"AlphaNumeric",
				"Numeric",
				"BigInteger",
				"Integer",
				"Long",
				"Short",
				"Decimal",
				"Float",
				"Double",
				"Boolean",
				"URI",
				"Count",
				"InclusiveValueRange",
				"ExclusiveValueRange",
				"Incremental",
				"ObservationalTimePeriod",
				"StandardTimePeriod",
				"BasicTimePeriod",
				"GregorianTimePeriod",
				"GregorianYear",
				"GregorianYearMonth",
				"GregorianDay",
				"ReportingTimePeriod",
				"ReportingYear",
				"ReportingSemester",
				"ReportingTrimester",
				"ReportingQuarter",
				"ReportingMonth",
				"ReportingWeek",
				"ReportingDay",
				"DateTime",
				"TimeRange",
				"Month",
				"MonthDay",
				"Day",
				"Time",
				"Duration",
				"GeospatialInformation",
				"XHTML"
			]
		},
		"BasicTimePeriodType":{
			"description":"BasicTimePeriodType contains the basic dates and calendar periods. It is a combination of the Gregorian time periods and the date time type.",
			"type":"string",
			"anyOf":[
				{
					"description":"xs:gYear: GregorianTimePeriodType defines the set of standard calendar periods in SDMX.",
					"pattern":"^([1-9][0-9]{3,}|0[0-9]{3})(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$"
				},
				{
					"description":"xs:gYearMonth: GregorianTimePeriodType defines the set of standard calendar periods in SDMX.",
					"pattern":"^([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$"
				},
				{
					"format":"date"
				},
				{
					"format":"date-time"
				}
			]
		},
		"CubeRegionKeyType":{
			"description":"CubeRegionKeyType is a type for providing a set of values for a dimension for the purpose of defining a data cube region. A set of distinct value can be provided, or if this dimension is represented as time, and time range can be specified.",
			"type":"object",
			"properties":{
				"id":{
					"$ref":"#/definitions/SingleNCNameIDType"
				},
				"include":{
					"type":"boolean",
					"description":"The include attribute indicates whether the values provided for the referenced component are to be included are excluded from the region in which they are defined."
				},
				"removePrefix":{
					"type":"boolean",
					"description":"The removePrefix attribute indicates whether codes should keep or not the prefix, as defined in the extension of codelist."
				},
				"validFrom":{
					"$ref":"#/definitions/StandardTimePeriodType"
				},
				"validTo":{
					"$ref":"#/definitions/StandardTimePeriodType"
				},
				"timeRange":{
					"$ref":"#/definitions/TimeRangeValueType"
				},
				"values":{
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/SimpleComponentValueType"
					}
				}
			},
			"required":[
				"id"
			],
			"anyOf":[
				{
					
				},
				{
					"required":[
						"timeRange"
					]
				},
				{
					"required":[
						"values"
					]
				}
			],
			"not":{
				"required":[
					"timeRange",
					"values"
				]
			}
		},
		"CubeRegionType":{
			"description":"CubeRegionType defines the structure of a data cube region. This is based on the abstract RegionType and simply refines the key and attribute values to conform with what is applicable for dimensions and attributes, respectively. See the documentation of the base type for more details on how a region is defined.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/AnnotableType"
				},
				{
					"properties":{
						"include":{
							"type":"boolean",
							"default":true,
							"description":"The include attribute indicates that the region is to be included or excluded within the context in which it is defined. For example, if the regions is defined as part of a content constraint, the exclude flag would mean the data identified by the region is not present."
						},
						"components":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/ComponentValueSetType",
								"description":"Component contains a reference to a component (data attribute, metadata attribute, or measure) and provides a collection of values for the referenced component. This serves to state that for the key which defines the region, the components that are specified here have or do not have (depending on the include attribute of the value set) the values provided. It is possible to provide a component reference without specifying values, for the purpose of stating the component is absent (include = false) or present with an unbounded set of values. As opposed to key components, which are assumed to be wild carded if absent, no assumptions are made about the absence of a component. Only components which are explicitly stated to be present or absent from the region will be know. All unstated components for the set cannot be assumed to absent or present."
							}
						},
						"keyValues":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/CubeRegionKeyType",
								"description":"KeyValue contains a reference to a component which disambiguates the data (i.e. a dimension) and provides a collection of values for the component. The collection of values can be flagged as being inclusive or exclusive to the region being defined. Any key component that is not included is assumed to be wild carded, which is to say that the cube includes all possible values for the un-referenced key components. Further, this assumption applies to the values of the components as well. The values for any given component can only be sub-setted in the region by explicit inclusion or exclusion. For example, a dimension X which has the possible values of 1, 2, 3 is assumed to have all of these values if a key value is not defined. If a key value is defined with an inclusion attribute of true and the values of 1 and 2, the only the values of 1 and 2 for dimension X are included in the definition of the region. If the key value is defined with an inclusion attribute of false and the value of 1, then the values of 2 and 3 for dimension X are included in the definition of the region. Note that any given key component must only be referenced once in the region."
							}
						}
					}
				}
			]
		},
		"DataKeyType":{
			"description":"DataKeyType is a region which defines a distinct full or partial data key. The key consists of a set of values, each referencing a dimension and providing a single value for that dimension. The purpose of the key is to define a subset of a data set (i.e. the observed value and data attribute) which have the dimension values provided in this definition. Any dimension not stated explicitly in this key is assumed to be wild carded, thus allowing for the definition of partial data keys.",
			"type":"object",
			"properties":{
				"annotations":{
					"$ref":"#/definitions/AnnotationsType"
				},
				"keyValues":{
					"type":"array",
					"minItems":0,
					"items":{
						"$ref":"#/definitions/DataKeyValueType"
					}
				},
				"components":{
					"type":"array",
					"minItems":0,
					"items":{
						"$ref":"#/definitions/DataComponentValueSetType"
					}
				},
				"include":{
					"const":true,
					"description":"The include attribute has a fixed value of true for a distinct key, since such a key is always assumed to identify existing data or metadata."
				},
				"validFrom":{
					"$ref":"#/definitions/StandardTimePeriodType"
				},
				"validTo":{
					"$ref":"#/definitions/StandardTimePeriodType"
				}
			}
		},
		"DataKeyValueType":{
			"description":"DataKeyValueType is a type for providing a dimension value for the purpose of defining a distinct data key. Only a single value can be provided for the dimension.",
			"type":"object",
			"properties":{
				"id":{
					"$ref":"#/definitions/SingleNCNameIDType"
				},
				"include":{
					"type":"boolean",
					"description":"The include attribute indicates whether the values provided for the referenced component are to be included are excluded from the region in which they are defined."
				},
				"removePrefix":{
					"type":"boolean",
					"description":"The removePrefix attribute indicates whether codes should keep or not the prefix, as defined in the extension of codelist."
				},
				"value":{
					"$ref":"#/definitions/SimpleKeyValueType"
				}
			},
			"required":[
				"id",
				"value"
			]
		},
		"DataType":{
			"description":"DataTypeType provides an enumerated list of the types of data formats allowed as the for the representation of an object.",
			"type":"string",
			"enum":[
				"String",
				"Alpha",
				"AlphaNumeric",
				"Numeric",
				"BigInteger",
				"Integer",
				"Long",
				"Short",
				"Decimal",
				"Float",
				"Double",
				"Boolean",
				"URI",
				"Count",
				"InclusiveValueRange",
				"ExclusiveValueRange",
				"Incremental",
				"ObservationalTimePeriod",
				"StandardTimePeriod",
				"BasicTimePeriod",
				"GregorianTimePeriod",
				"GregorianYear",
				"GregorianYearMonth",
				"GregorianDay",
				"ReportingTimePeriod",
				"ReportingYear",
				"ReportingSemester",
				"ReportingTrimester",
				"ReportingQuarter",
				"ReportingMonth",
				"ReportingWeek",
				"ReportingDay",
				"DateTime",
				"TimeRange",
				"Month",
				"MonthDay",
				"Day",
				"Time",
				"Duration",
				"GeospatialInformation",
				"XHTML",
				"KeyValues",
				"IdentifiableReference",
				"DataSetReference"
			]
		},
		"EmptyType":{
			"description":"EmptyType is an empty complex type for elements where the presence of the tag indicates all that is necessary.",
			"type":"object"
		},
		"MetadataAttributeValueSetType":{
			"description":"MetadataAttributeValueSetType defines the structure for providing values for a metadata attribute. If no values are provided, the attribute is implied to include/excluded from the region in which it is defined, with no regard to the value of the metadata attribute.",
			"type":"object",
			"properties":{
				"id":{
					"$ref":"#/definitions/NestedNCNameIDType",
					"description":"The id attribute provides the identifier for the component for which values are being provided. This base type allows for a nested identifier to be provided, for the purpose of referencing a nested component (i.e. a metadata attribute). However, specific implementations will restrict this representation to only allow single level identifiers where appropriate."
				},
				"include":{
					"type":"boolean",
					"description":"The include attribute indicates whether the values provided for the referenced component are to be included are excluded from the region in which they are defined."
				},
				"removePrefix":{
					"type":"boolean",
					"description":"The removePrefix attribute indicates whether codes should keep or not the prefix, as defined in the extension of codelist."
				},
				"timeRange":{
					"$ref":"#/definitions/TimeRangeValueType"
				},
				"values":{
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/SimpleComponentValueType"
					}
				}
			},
			"required":[
				"id"
			],
			"anyOf":[
				{
					
				},
				{
					"required":[
						"timeRange"
					]
				},
				{
					"required":[
						"values"
					]
				}
			],
			"not":{
				"required":[
					"timeRange",
					"values"
				]
			}
		},
		"SimpleComponentValueType":{
			"description":"SimpleComponentValueType contains a simple value for a component, and if that value is from a code list, the ability to indicate that child codes in a simple hierarchy are part of the value set of the component for the region.",
			"oneOf":[
				{
					"type":"string"
				},
				{
					"type":"object",
					"required":[
						"value"
					],
					"properties":{
						"value":{
							"type":"string"
						},
						"cascadeValues":{
							"$ref":"#/definitions/CascadeSelectionType",
							"default":false
						},
						"lang":{
							"type":"string",
							"pattern":"^(?:(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))$|^((?:[a-z]{2,3}(?:(?:-[a-z]{3}){1,3})?)|[a-z]{4}|[a-z]{5,8})(?:-([a-z]{4}))?(?:-([a-z]{2}|[0-9]{3}))?((?:-(?:[0-9a-z]{5,8}|[0-9][0-9a-z]{3}))*)?((?:-[0-9a-wy-z](?:-[0-9a-z]{2,8})+)*)?(-x(?:-[0-9a-z]{1,8})+)?$|^(x(?:-[0-9a-z]{1,8})+)$"
						},
						"validFrom":{
							"$ref":"#/definitions/StandardTimePeriodType"
						},
						"validTo":{
							"$ref":"#/definitions/StandardTimePeriodType"
						}
					}
				}
			]
		},
		"DataComponentValueType":{
			"description":"DataComponentValueType derives from the SimpleComponentValueType, but does not allow for validity dates.",
			"oneOf":[
				{
					"type":"string"
				},
				{
					"type":"object",
					"required":[
						"value"
					],
					"properties":{
						"value":{
							"type":"string"
						},
						"cascadeValues":{
							"$ref":"#/definitions/CascadeSelectionType",
							"default":false
						},
						"lang":{
							"type":"string",
							"pattern":"^(?:(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))$|^((?:[a-z]{2,3}(?:(?:-[a-z]{3}){1,3})?)|[a-z]{4}|[a-z]{5,8})(?:-([a-z]{4}))?(?:-([a-z]{2}|[0-9]{3}))?((?:-(?:[0-9a-z]{5,8}|[0-9][0-9a-z]{3}))*)?((?:-[0-9a-wy-z](?:-[0-9a-z]{2,8})+)*)?(-x(?:-[0-9a-z]{1,8})+)?$|^(x(?:-[0-9a-z]{1,8})+)$"
						}
					}
				}
			]
		},
		"MetadataTargetRegionType":{
			"description":"MetadataTargetRegionType defines the structure of a metadata target region. A metadata target region must define the report structure and the metadata target from that structure on which the region is based. This type is based on the abstract RegionType and simply refines the key and attribute values to conform with what is applicable for target objects and metadata attributes, respectively. See the documentation of the base type for more details on how a region is defined.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/AnnotableType"
				},
				{
					"properties":{
						"include":{
							"type":"boolean",
							"default":true,
							"description":"The include attribute indicates that the region is to be included or excluded within the context in which it is defined. For example, if the regions is defined as part of a content constraint, the exclude flag would mean the data identified by the region is not present."
						},
						"components":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/MetadataAttributeValueSetType"
							}
						},
						"validFrom":{
							"$ref":"#/definitions/StandardTimePeriodType"
						},
						"validTo":{
							"$ref":"#/definitions/StandardTimePeriodType"
						}
					}
				}
			]
		},
		"NestedIDType":{
			"description":"NestedIDType is the least restrictive form of an identifier used throughout all SDMX-ML messages. It allows for a hierarchical identifier, with each portion separated by the '.' character. For the identifier portions, valid characters include A-Z, a-z, @, 0-9, _, -, $.",
			"type":"string",
			"pattern":"^[A-Za-z0-9_@$-]+(\\.[A-Za-z0-9_@$-]+)*$"
		},
		"WildcardType":{
			"description":"WildcardType is a single value code list, used to include the '*' character - indicating that the identification component is wildcarded and that any value of the identifier component is allowed.",
			"const":"*"
		},
		"WildcardNestedIDType":{
			"description":"WildcardNestedIDType combines the NestedIDType and WildcardType to allow a reference to either a specific nested identifier, or to wildcard the identifier in the reference by specifying the '*' value.",
			"anyOf":[
				{
					"$ref":"#/definitions/NestedIDType"
				},
				{
					"$ref":"#/definitions/WildcardType"
				}
			]
		},
		"WildcardVersionType":{
			"description":"WildcardVersionType combines the VersionType and WildcardType to allow a reference to either a specific version of an object, or to wildcard the version in the reference by specifying the '*' value.",
			"anyOf":[
				{
					"$ref":"#/definitions/VersionReferenceType"
				},
				{
					"$ref":"#/definitions/WildcardType"
				}
			]
		},
		"NCNameIDType":{
			"description":"NCNameIDType restricts the IDType, so that the id may be used to generate valid XML components. IDs created from this type conform to the W3C XML Schema NCNAME type, and therefore can be used as element or attribute names.",
			"type":"string",
			"pattern":"^[A-Za-z][A-Za-z0-9_-]*$"
		},
		"NestedNCNameIDType":{
			"description":"NestedNCNameIDType restricts the NestedIDType, so that the id may be used to generate valid XML components. IDs created from this type conform to the W3C XML Schema NCNAME type, and therefore can be used as element or attribute names. Regex: [A-Za-z][A-Za-z0-9_\\-]*(\\.[A-Za-z][A-Za-z0-9_\\-]*)* ",
			"type":"string",
			"pattern":"^[A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*$"
		},
		"ObservationalTimePeriodType":{
			"description":"ObservationalTimePeriodType specifies a distinct time period or point in time in SDMX. The time period can either be a Gregorian calendar period, a standard reporting period, a distinct point in time, or a time range with a specific date and duration.",
			"anyOf":[
				{
					"$ref":"#/definitions/BasicTimePeriodType"
				},
				{
					"$ref":"#/definitions/ReportingTimePeriodType"
				},
				{
					"description":"TimeRangeType 1",
					"type":"string",
					"pattern":"^.+/P.*T([0-9]+H)?([0-9]+M)?([0-9]+(.[0-9]+)?S)?$"
				},
				{
					"description":"TimeRangeType 2",
					"type":"string",
					"pattern":"^.+/P[^T]+$"
				}
			]
		},
		"OccurenceType":{
			"description":"OccurenceType is used to express the maximum occurrence of an object. It combines an integer, greater than 1, and the literal text, \"unbounded\", for objects which have no upper limit on its occurrence.",
			"anyOf":[
				{
					"description":"MaxOccursNumberType is a base type used to restrict an integer to be greater than 1, for the purpose of expressing the maximum number of occurrences of an object.",
					"type":"integer",
					"minimum":1
				},
				{
					"description":"UnboundedCodeType provides single textual value of \"unbounded\", for use in OccurentType.",
					"const":"unbounded"
				}
			]
		},
		"QueryableDataSourceType":{
			"description":"QueryableDataSourceType describes a data source which accepts an standard SDMX Query message and responds appropriately.",
			"type":"object",
			"properties":{
				"isRESTDatasource":{
					"type":"boolean"
				},
				"isWebServiceDatasource":{
					"type":"boolean"
				},
				"dataURL":{
					"description":"DataURL contains the URL of the data source.",
					"$ref":"#/definitions/uri"
				},
				"wadlURL":{
					"description":"WADLURL provides the location of a WADL instance on the internet which describes the REST protocol of the queryable data source.",
					"$ref":"#/definitions/uri"
				},
				"wsdlURL":{
					"description":"WSDLURL provides the location of a WSDL instance on the internet which describes the queryable data source.",
					"$ref":"#/definitions/uri"
				}
			},
			"required":[
				"isRESTDatasource",
				"isWebServiceDatasource",
				"dataURL"
			]
		},
		"ReferencePeriodType":{
			"description":"Specifies the inclusive start and end times for the reference period.",
			"type":"object",
			"properties":{
				"endTime":{
					"type":"string",
					"format":"date-time"
				},
				"startTime":{
					"type":"string",
					"format":"date-time"
				}
			},
			"required":[
				"endTime",
				"startTime"
			]
		},
		"ReportingTimePeriodType":{
			"description":"ReportingTimePeriodType defines standard reporting periods in SDMX, which are all in relation to the start day (day-month) of a reporting year which is specified in the specialized reporting year start day attribute. If the reporting year start day is not defined, a day of January 1 is assumed. The reporting year must be epxressed as the year at the beginning of the period. Therfore, if the reproting year runs from April to March, any given reporting year is expressed as the year for April. The general format of a report period can be described as  [year]-[period][time zone]?, where the type of period is designated with a single character followed by a number representing the period. Note that all periods allow for an optional time zone offset. See the details of each member type for the specifics of its format. It can be one one the following sub-types: (1) ReportingYearType defines a time period of 1 year (P1Y) in relation to a reporting year which has a start day (day-month) specified in the specialized reporting year start day attribute. In the absence of a start day for the reporting year, a day of January 1 is assumed. In this case a reporting year will coincide with a calendar year. The format of a reporting year is YYYY-A1 (e.g. 2000-A1). Note that the period value of 1 is fixed. (2) ReportingSemesterType defines a time period of 6 months (P6M) in relation to a reporting year which has a start day (day-month) specified in the specialized reporting year start day attribute. In the absence of a start day for the reporting year, a day of January 1 is assumed. The format of a reporting semester is YYYY-Ss (e.g. 2000-S1), where s is either 1 or 2. (3) ReportingTrimesterType defines a time period of 4 months (P4M) in relation to a reporting year which has a start day (day-month) specified in the specialized reporting year start day attribute. In the absence of a start day for the reporting year, a day of January 1 is assumed. The format of a reporting trimester is YYYY-Tt (e.g. 2000-T1), where s is either 1, 2, or 3. (4) ReportingQuarterType defines a time period of 3 months (P3M) in relation to a reporting year which has a start day (day-month) specified in the specialized reporting year start day attribute. In the absence of a start day for the reporting year, a day of January 1 is assumed. The format of a reporting quarter is YYYY-Qq (e.g. 2000-Q1), where q is a value between 1 and 4. (5) ReportingMonthType defines a time period of 1 month (P1M) in relation to a reporting year which has a start day (day-month) specified in the specialized reporting year start day attribute. In the absence of a start day for the reporting year, a day of January 1 is assumed. In this case a reporting month will coincide with a calendar month. The format of a reporting month is YYYY-Mmm (e.g. 2000-M01), where mm is a two digit month (i.e. 01-12). (6) ReportingWeekType defines a time period of 7 days (P7D) in relation to a reporting year which has a start day (day-month) specified in the specialized reporting year start day attribute. A standard reporting week is based on the ISO 8601 defintion of a week date, in relation to the reporting period start day. The first week is defined as the week with the first Thursday on or after the reporting year start day. An equivalent definition is the week starting with the Monday nearest in time to the reporting year start day. There are other equivalent defintions, all of which should be adjusted based on the reporting year start day. In the absence of a start day for the reporting year, a day of January 1 is assumed. The format of a reporting week is YYYY-Www (e.g. 2000-W01), where mm is a two digit week (i.e. 01-53). (7) ReportingDayType defines a time period of 1 day (P1D) in relation to a reporting year which has a start day (day-month) specified in the specialized reporting year start day attribute. In the absence of a start day for the reporting year, a day of January 1 is assumed. The format of a reporting day is YYYY-Dddd (e.g. 2000-D001), where ddd is a three digit day (i.e. 001-366).",
			"type":"string",
			"pattern":"^\\d{4}\\-([ASTQ]\\d{1}|[MW]\\d{2}|[D]\\d{3})(Z|((\\+|\\-)\\d{2}:\\d{2}))?$"
		},
		"SimpleDataType":{
			"description":"SimpleDataType restricts BasicComponentDataType to specify the allowable data types for a data structure definition component. The XHTML representation is removed as a possible type.",
			"type":"string",
			"enum":[
				"String",
				"Alpha",
				"AlphaNumeric",
				"Numeric",
				"BigInteger",
				"Integer",
				"Long",
				"Short",
				"Decimal",
				"Float",
				"Double",
				"Boolean",
				"URI",
				"Count",
				"InclusiveValueRange",
				"ExclusiveValueRange",
				"Incremental",
				"ObservationalTimePeriod",
				"StandardTimePeriod",
				"BasicTimePeriod",
				"GregorianTimePeriod",
				"GregorianYear",
				"GregorianYearMonth",
				"GregorianDay",
				"ReportingTimePeriod",
				"ReportingYear",
				"ReportingSemester",
				"ReportingTrimester",
				"ReportingQuarter",
				"ReportingMonth",
				"ReportingWeek",
				"ReportingDay",
				"DateTime",
				"TimeRange",
				"Month",
				"MonthDay",
				"Day",
				"Time",
				"Duration",
				"GeospatialInformation"
			]
		},
		"SimpleKeyValueType":{
			"description":"SimpleKeyValueType derives from the SimpleComponentValueType, but does not allow for the cascading of value in the hierarchy, as keys are meant to describe a distinct full or partial key.",
			"type":"string"
		},
		"SingleNCNameIDType":{
			"description":"SingleNCNameIDType restricts the NestedNCNameIDType to allow only one level. Note that this is the same pattern as the NCNameIDType, but can be used when the base type to be restricted is a nested NCNameIDType (where as the NCNameIDType could only restrict the IDType).",
			"type":"string",
			"pattern":"^[A-Za-z][A-Za-z0-9_-]*$"
		},
		"StandardTimePeriodType":{
			"description":"StandardTimePeriodType defines the set of standard time periods in SDMX. This includes the reporting time periods and the basic date type (i.e. the calendar time periods and the dateTime format).",
			"anyOf":[
				{
					"description":"xs:gYear: GregorianTimePeriodType defines the set of standard calendar periods in SDMX.",
					"type":"string",
					"pattern":"^([1-9][0-9]{3,}|0[0-9]{3})(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$"
				},
				{
					"description":"xs:gYearMonth: GregorianTimePeriodType defines the set of standard calendar periods in SDMX.",
					"type":"string",
					"pattern":"^([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$"
				},
				{
					"type":"string",
					"format":"date"
				},
				{
					"type":"string",
					"format":"date-time"
				},
				{
					"$ref":"#/definitions/ReportingTimePeriodType",
					"description":"ReportingTimePeriodType defines standard reporting periods in SDMX, which are all in relation to the start day (day-month) of a reporting year which is specified in the specialized reporting year start day attribute. If the reporting year start day is not defined, a day of January 1 is assumed. The reporting year must be epxressed as the year at the beginning of the period. Therfore, if the reproting year runs from April to March, any given reporting year is expressed as the year for April. The general format of a report period can be described as  [year]-[period][time zone]?, where the type of period is designated with a single character followed by a number representing the period. Note that all periods allow for an optional time zone offset. See the details of each member type for the specifics of its format."
				}
			]
		},
		"TimeDataType":{
			"description":"TimeDataType restricts SimpleDataType to specify the allowable data types for representing a time value.",
			"type":"string",
			"enum":[
				"ObservationalTimePeriod",
				"StandardTimePeriod",
				"BasicTimePeriod",
				"GregorianTimePeriod",
				"GregorianYear",
				"GregorianYearMonth",
				"GregorianDay",
				"ReportingTimePeriod",
				"ReportingYear",
				"ReportingSemester",
				"ReportingTrimester",
				"ReportingQuarter",
				"ReportingMonth",
				"ReportingWeek",
				"ReportingDay",
				"DateTime",
				"TimeRange"
			]
		},
		"TimePeriodRangeType":{
			"description":"TimePeriodRangeType defines a time period, and indicates whether it is inclusive in a range.",
			"type":"object",
			"properties":{
				"period":{
					"$ref":"#/definitions/ObservationalTimePeriodType"
				},
				"isInclusive":{
					"type":"boolean",
					"default":true
				}
			},
			"required":[
				"period"
			]
		},
		"TimeRangeValueType":{
			"description":"TimeRangeValueType allows a time period value to be expressed as a range. It can be expressed as the period before a period, after a period, or between two periods. Each of these properties can specify their inclusion in regards to the range.",
			"type":"object",
			"oneOf":[
				{
					"required":[
						"afterPeriod"
					],
					"properties":{
						"afterPeriod":{
							"$ref":"#/definitions/TimePeriodRangeType",
							"description":"AfterPeriod is the period after which the period is meant to cover. This date may be inclusive or exclusive in the range."
						}
					}
				},
				{
					"required":[
						"beforePeriod"
					],
					"properties":{
						"beforePeriod":{
							"$ref":"#/definitions/TimePeriodRangeType",
							"description":"BeforePeriod is the period before which the period is meant to cover. This date may be inclusive or exclusive in the range."
						}
					}
				},
				{
					"required":[
						"endPeriod",
						"startPeriod"
					],
					"properties":{
						"endPeriod":{
							"$ref":"#/definitions/TimePeriodRangeType",
							"description":"EndPeriod is the end period of the range. This date may be inclusive or exclusive in the range."
						},
						"startPeriod":{
							"$ref":"#/definitions/TimePeriodRangeType",
							"description":"StartPeriod is the start date or the range that the queried date must occur within. This date may be inclusive or exclusive in the range."
						}
					}
				}
			]
		},
		"VersionType":{
			"description":"VersionType is used to communicate version information. The format is restricted to allow for simple incrementing and sorting of version number. The version consists of an unlimited set of numeric components, separated by the '.' character. When processing version, each numeric component (the number preceding and following any '.' character) should be parsed as an integer. Thus, a version of 1.3 and 1.03 would be equivalent, as both the '3' component and the '03' component would parse to an integer value of 3.",
			"type":"string",
			"anyOf":[
				{
					"pattern":"^(0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?$",
					"description":"Legacy version format: describes the version number format previously supported in SDMX. The format is restricted to allow for simple incrementing and sorting of version number. The version consists of an unlimited set of numeric components, separated by the '.' character. When processing version, each numeric component (the number preceding and following any '.' character) should be parsed as an integer. Thus, a version of 1.3 and 1.03 would be equivalent, as both the '3' component and the '03' component would parse to an integer value of 3."
				},
				{
					"pattern":"^(0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?$",
					"description":"Semantic version format: is a simple type for validating semantic version in the format major.minor.patch[-extension]."
				}
			]
		},
		"VersionReferenceType":{
			"description":"VersionReferenceType defines the structure of version number in a reference. When semantic versioning is used, the major, minor, or patch version parts can be wildcarded using '+' as an extension. For example, 2+.3.1 means the currently latest available version >= 2.3.1 (even if not backwards compatible). Note that wildcarded semantic version references cannot be combined with version extended reference (e.g. 2.3+.1-draft is not permissable). Version-extended (e.g. 1.3.1-draft) and legacy version numbers (e.g. 1 or 1.0) are also supported.",
			"type":"string",
			"anyOf":[
				{
					"pattern":"^(0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?$",
					"description":"Legacy version format: describes the version number format previously supported in SDMX. The format is restricted to allow for simple incrementing and sorting of version number. The version consists of an unlimited set of numeric components, separated by the '.' character. When processing version, each numeric component (the number preceding and following any '.' character) should be parsed as an integer. Thus, a version of 1.3 and 1.03 would be equivalent, as both the '3' component and the '03' component would parse to an integer value of 3."
				},
				{
					"pattern":"^(0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?$",
					"description":"Semantic version format: is a simple type for validating semantic version in the format major.minor.patch[-extension]."
				},
				{
					"pattern":"(^(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)$)|(^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)$)|(^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+$)",
					"description":"Semantic version reference is a simple type for referencing semantic version numbers. It allows for the wildcarding of one of the major, minor, or patch version parts using '+'."
				}
			]
		},
		"ExplicitVersionType":{
			"allOf":[
				{
					"$ref":"#/definitions/VersionReferenceType"
				},
				{
					"pattern":"^[^\\*]*$"
				}
			],
			"description":"A restriction of WildcardVersionType the does not allow wildcarding. It reduces again to the VersionReferenceType. This allows proper retrictions to be placed on explicit references."
		},
		"AgencySchemeType":{
			"description":"AgencySchemeType defines a specific type of organisation scheme which contains only maintenance agencies. The agency scheme maintained by a particular maintenance agency is always provided a fixed identifier and is never versioned. Therefore, agencies can be added or removed without have to version the scheme. Agencies schemes have no hierarchy, meaning that no agency may define a relationship with another agency in the scheme. In fact, the actual parent agency for an agency in a scheme is the agency which defines the scheme.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableWithoutVersionType"
				},
				{
					"properties":{
						"id":{
							"const":"AGENCIES"
						},
						"isPartial":{
							"type":"boolean",
							"description":"isPartial, if true, indicates that only the relevant portion of the agency scheme is being communicated."
						},
						"agencies":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/AgencyType",
								"description":"Agency is an organisation which maintains structural metadata such as classifications, concepts, data structures, and metadata structures."
							}
						}
					}
				}
			]
		},
		"AgencyType":{
			"description":"AgencyType defines the structure of an agency description. The contacts defined for the organisation are specific to the agency role the organisation is serving.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/NameableTypeWithNCNameID"
				},
				{
					"properties":{
						"contacts":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/contactType"
							}
						}
					},
					"required":[
						"id"
					]
				}
			]
		},
		"MetadataConstraintAttachmentType":{
			"description":"MetadataConstraintAttachmentType restricts the base ConstraintAttachmentType to only allow artefacts related to metadata.",
			"type":"object",
			"oneOf":[
				{
					"required":[
						"metadataProvider"
					],
					"properties":{
						"metadataProvider":{
							"$ref":"#/definitions/MetadataProviderReferenceType",
							"description":"metadataProvider is a urn reference to a the metadata provider of the metadata set to which the constraint is attached. If this is used, then only the release calendar is relevant."
						}
					}
				},
				{
					"required":[
						"metadataSets"
					],
					"properties":{
						"metadataSets":{
							"type":"array",
							"uniqueItems":true,
							"minItems":1,
							"items":{
								"$ref":"#/definitions/MetadataSetReferenceType",
								"description":"MetadataSet is a urn reference to a metadata set to which the constraint is attached. Multiple instance can only be used if they have the same underlying structure."
							}
						}
					}
				},
				{
					"required":[
						"simpleDataSources"
					],
					"properties":{
						"simpleDataSources":{
							"type":"array",
							"uniqueItems":true,
							"minItems":1,
							"items":{
								"description":"SimpleDataSource describes a simple data source, which is a URL of a SDMX-ML data or metadata message. Multiple instance can only be used if they have the same underlying structure.",
								"$ref":"#/definitions/uri"
							}
						}
					}
				},
				{
					"required":[
						"metadataStructures"
					],
					"properties":{
						"metadataStructures":{
							"type":"array",
							"uniqueItems":true,
							"minItems":1,
							"items":{
								"$ref":"#/definitions/MetadataStructureReferenceType",
								"description":"Urn reference to a metadata structure definition to which the constraint is attached. A constraint which is attached to more than one metadata structure must only express key sets and/or target regions where the identifiers of the target objects are common across all structures to which the constraint is attached."
							}
						},
						"queryableDataSources":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/QueryableDataSourceType",
								"description":"queryableDataSource describes a queryable data source to which the constraint is attached."
							}
						}
					}
				},
				{
					"required":[
						"metadataflows"
					],
					"properties":{
						"metadataflows":{
							"type":"array",
							"uniqueItems":true,
							"minItems":1,
							"items":{
								"$ref":"#/definitions/MetadataflowReferenceType",
								"description":"Urn reference to a metadata flow object to which the constraint is attached. A constraint can be attached to more than one metadataflow, and the metadataflows do not necessarily have to be usages of the same metadata structure. However, a constraint which is attached to more than one metadata structure must only express key sets and/or target regions where the identifiers of the target objects are common across all structures to which the constraint is attached."
							}
						},
						"queryableDataSources":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/QueryableDataSourceType",
								"description":"queryableDataSource describes a queryable data source to which the constraint is attached."
							}
						}
					}
				},
				{
					"required":[
						"metadataProvisionAgreements"
					],
					"properties":{
						"metadataProvisionAgreements":{
							"type":"array",
							"uniqueItems":true,
							"minItems":1,
							"items":{
								"$ref":"#/definitions/MetadataProvisionAgreementReferenceType",
								"description":"Urn reference to a metadata provision agreement to which the constraint is attached. A constraint can be attached to more than one metadata provision agreement, and the metadata provision agreements do not necessarily have to be references structure usages based on the same structure. However, a constraint which is attached to more than one metadata provision agreement must only express key sets and/or cube/target regions where the identifier of the components are common across all structures to which the constraint is attached."
							}
						},
						"queryableDataSources":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/QueryableDataSourceType",
								"description":"queryableDataSource describes a queryable data source to which the constraint is attached."
							}
						}
					}
				}
			]
		},
		"MetadataConstraintType":{
			"description":"MetadataConstraintType defines the structure of a metadata constraint, which specifies a sub set of the definition of the allowable content of a metadata set. A metadata constraint can specify allowed attribute values for metadata described by the constrained artefact. The constraint attachment is restricted to constrainable artefacts related to metadata, and the only possible role is 'Allowed'. Unless the artefact is returned as a stub, it must contain the 'role' property.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableType"
				},
				{
					"properties":{
						"role":{
							"const":"Allowed",
							"description":"The fixed 'Allowed' role attribute indicates that this constraint defines what content is allowed."
						},
						"constraintAttachment":{
							"$ref":"#/definitions/MetadataConstraintAttachmentType",
							"description":"ConstraintAttachment describes the collection of constrainable artefacts that the constraint is attached to."
						},
						"releaseCalendar":{
							"$ref":"#/definitions/ReleaseCalendarType",
							"description":"ReleaseCalendar defines dates on which the constrained metadata is to be made available."
						},
						"metadataTargetRegions":{
							"type":"array",
							"minItems":1,
							"maxItems":2,
							"items":{
								"$ref":"#/definitions/MetadataTargetRegionType",
								"description":"MetadataTargetRegion describes the values allowed for metadata attributes. A set of either included or excluded regions can be described."
							}
						}
					}
				}
			]
		},
		"AttributeListType":{
			"description":"AttributeListType describes the attribute descriptor for the data structure definition.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/AnnotableType"
				},
				{
					"properties":{
						"id":{
							"const":"AttributeDescriptor",
							"description":"The id attribute is provided in this case for completeness. However, its value is fixed to AttributeDescriptor."
						},
						"links":{
							"$ref":"#/definitions/links",
							"description":"Links field is an array of link objects. Also used to specify the URI or the URN to itself. If appropriate, a collection of links to additional external resources."
						},
						"attributes":{
							"type":"array",
							"minItems":1,
							"items":{
								"anyOf":[
									{
										"$ref":"#/definitions/AttributeType",
										"description":"Attribute describes the definition of a data attribute, which is defined as a characteristic of an object or entity."
									},
									{
										"$ref":"#/definitions/ReportingYearStartOrEndDayType",
										"description":"ReportingYearStartDay and ReportingYearEndDay are specialized data attributes which provide important context to the time dimension. If the value of the time dimension is one of the standard reporting periods (see common:ReportingTimePeriodType) then one of these attributes is used to state the month and day that the reporting year begins or ends. This provides a reference point from which the actual calendar dates covered by these periods can be determined. If this attribute does not occur in a data set, then the reporting year start/end day will be assumed to be January 1/December 31."
									}
								]
							}
						},
						"metadataAttributeUsages":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/MetadataAttributeUsageType",
								"description":"MetadataAttributeUsage refines the details of how a metadata attribute from the metadata structure referenced from the data structure is used. By default, metadata attributes can be expressed at any level of the data. This allows an attribute relationship to be defined in order restrict the reporing of a metadata attribute to a specific part of the data."
							}
						}
					}
				}
			]
		},
		"MetadataAttributeListType":{
			"description":"MetadataAttributeListType describes the structure of a meta data attribute list. It comprises a set of metadata attributes that can be defined as a hierarchy.",
			"type":"object",
			"required":[
				"metadataAttributes"
			],
			"allOf":[
				{
					"$ref":"#/definitions/AnnotableType"
				},
				{
					"properties":{
						"id":{
							"const":"MetadataAttributeDescriptor",
							"description":"The id attribute is provided in this case for completeness. However, its value is fixed to MetadataAttributeDescriptor."
						},
						"links":{
							"$ref":"#/definitions/links",
							"description":"Links field is an array of link objects. Also used to specify the URI or the URN to itself. If appropriate, a collection of links to additional external resources."
						},
						"metadataAttributes":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/MetadataAttributeType",
								"description":"MetadataAttribute defines the a metadata attribute, which is the value of an attribute, such as the instance of a coded or uncoded attribute in a metadata structure definition."
							}
						}
					}
				}
			]
		},
		"MetadataAttributeUsageType":{
			"description":"MetadataAttributeUsageType defines the structure of how a metadata attribute is used in a data structure. This is a local reference to a metadata attribute from the metadata structure referenced by the data structure. An attribute relationship can be defined in order to describe the relationship of the metadata attribute to the data structure components.",
			"type":"object",
			"required":[
				"metadataAttributeReference",
				"attributeRelationship"
			],
			"allOf":[
				{
					"$ref":"#/definitions/AnnotableType"
				},
				{
					"properties":{
						"links":{
							"$ref":"#/definitions/links",
							"description":"Links field is an array of link objects. Also used to specify the URI or the URN to itself. If appropriate, a collection of links to additional external resources."
						},
						"metadataAttributeReference":{
							"$ref":"#/definitions/NestedIDType",
							"description":"MetadataAttributeReference is a local reference (nested ID) to a metadata attribute defined in the metadata structure referenced by this data structure."
						},
						"attributeRelationship":{
							"$ref":"#/definitions/AttributeRelationshipType",
							"description":"The attributeRelationship defines the relationship between the referenced metadata attribute and the components of the data structure."
						}
					}
				}
			]
		},
		"AttributeRelationshipType":{
			"description":"AttributeRelationship defines the structure for stating the relationship between an attribute and other data structure definition components.",
			"type":"object",
			"oneOf":[
				{
					"required":[
						"dataflow"
					],
					"properties":{
						"dataflow":{
							"$ref":"#/definitions/EmptyType",
							"description":"This means that the value of the attribute varies per dataflow. It is the data modeller's responsibility to design or use non-overlapping dataflows that do not have observations in common, otherwise the integrity of dataflow-specific attribute values is not assured by the model, e.g. when querying those data through its DSD. The level at which the unique attribute value will be presented in data messages depends on the data format."
						}
					}
				},
				{
					"required":[
						"dimensions"
					],
					"properties":{
						"dimensions":{
							"description":"This is used to reference dimensions in the data structure definition on which the value of this attribute depends. An attribute using this relationship can be either a group, series (or section), or observation level attribute. The attachment level of the attribute will be determined by the data format and which dimensions are referenced.",
							"type":"array",
							"uniqueItems":true,
							"minItems":1,
							"items":{
								"$ref":"#/definitions/NCNameIDType",
								"description":"One or more identifiers of (a) local dimension(s)."
							}
						},
						"areDimensionsOptional":{
							"description":"This is used to indicate those dimensions to which the attributes might optionally not be attached. The array structure must follow that for the dimensions.",
							"type":"array",
							"minItems":1,
							"items":{
								"type":"boolean"
							}
						}
					}
				},
				{
					"required":[
						"group"
					],
					"properties":{
						"group":{
							"$ref":"#/definitions/idType",
							"description":"Identifier of a local GroupKey Descriptor. This is used as a convenience to referencing all of the dimension defined by the referenced group. The level at which the attribute values will be presented in data messages depends on the data format and which dimensions are referenced. If the group (level) is available in the data format used then the attribute values should be presented at that group level."
						}
					}
				},
				{
					"required":[
						"observation"
					],
					"properties":{
						"observation":{
							"$ref":"#/definitions/EmptyType",
							"description":"This is used to specify that the value of the attribute may vary with any of the local dimensions and thus is dependent upon the observed value. An attribute with this relationship will its values always have presented at observation level."
						}
					}
				}
			]
		},
		"AttributeType":{
			"description":"AttributeType describes the structure of a data attribute, which is defined as a characteristic of an object or entity. The attribute takes its semantic, and in some cases it representation, from its concept identity. An attribute can be coded by referencing a code list from its coded local representation. It can also specify its text format, which is used as the representation of the attribute if a coded representation is not defined. Neither the coded or uncoded representation are necessary, since the attribute may take these from the referenced concept. An attribute specifies its relationship with other data structure components and is given an assignment status. These two properties dictate where in a data message the attribute will be attached, and whether or not the attribute will be required to be given a value. A set of roles defined in concept scheme can be assigned to the attribute.",
			"type":"object",
			"required":[
				"attributeRelationship",
				"conceptIdentity"
			],
			"allOf":[
				{
					"$ref":"#/definitions/IdentifiableTypeWithNCNameID"
				},
				{
					"properties":{
						"usage":{
							"$ref":"#/definitions/UsageType",
							"default":"optional",
							"description":"The usage attribute indicates whether an attribute value must be available for any corresponding existing observation."
						},
						"attributeRelationship":{
							"$ref":"#/definitions/AttributeRelationshipType",
							"description":"AttributeRelationship describes how the value of this attribute varies with the values of other components. These relationships will be used to determine the attachment level of the attribute in the various data formats."
						},
						"measureRelationship":{
							"type":"array",
							"uniqueItems":true,
							"minItems":1,
							"items":{
								"$ref":"#/definitions/NCNameIDType"
							},
							"description":"The measureRelationship array identifies the measures that the attribute applies to. If this is not used, the attribute is assumed to apply to all measures. If used, it contains one or more identifiers of (a) local measure(s)."
						},
						"conceptIdentity":{
							"$ref":"#/definitions/ConceptReferenceType",
							"description":"Urn reference to a concept where the identification of the concept scheme which defines it is contained in another context."
						},
						"conceptRoles":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/ConceptReferenceType",
								"description":"ConceptRole references concepts which define roles which this attribute serves. If the concept from which the attribute takes its identity also defines a role the concept serves, then the isConceptRole indicator can be set to true on the concept identity rather than repeating the reference here."
							}
						},
						"localRepresentation":{
							"$ref":"#/definitions/AttributeRepresentationType"
						}
					}
				}
			]
		},
		"BasicComponentTextFormatType":{
			"description":"BasicComponentTextFormatType is a restricted version of the TextFormatType that restricts the text type to the representations allowed for all components except for target objects.",
			"type":"object",
			"properties":{
				"dataType":{
					"$ref":"#/definitions/BasicComponentDataType"
				},
				"isSequence":{
					"type":"boolean"
				},
				"interval":{
					"type":"number"
				},
				"startValue":{
					"type":"number"
				},
				"endValue":{
					"type":"number"
				},
				"timeInterval":{
					"$ref":"#/definitions/duration"
				},
				"startTime":{
					"$ref":"#/definitions/StandardTimePeriodType"
				},
				"endTime":{
					"$ref":"#/definitions/StandardTimePeriodType"
				},
				"minLength":{
					"type":"integer",
					"minimum":1
				},
				"maxLength":{
					"type":"integer",
					"minimum":1
				},
				"minValue":{
					"type":"number"
				},
				"maxValue":{
					"type":"number"
				},
				"decimals":{
					"type":"integer",
					"minimum":1
				},
				"pattern":{
					"type":"string"
				},
				"isMultiLingual":{
					"type":"boolean"
				},
				"sentinelValues":{
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/sentinelValueType",
						"description":"SentinelValue defines a value that has a special meaning within the text format representation of a component."
					}
				}
			}
		},
		"CategorisationType":{
			"description":"CategorisationType defines the structure for a categorisation. A source object is referenced via an object reference and the target category is referenced via the target category.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableType"
				},
				{
					"properties":{
						"source":{
							"$ref":"#/definitions/urn",
							"description":"Source is a urn reference to an object to be categorized."
						},
						"target":{
							"$ref":"#/definitions/CategoryReferenceType",
							"description":"Target is a urn reference to the category that the referenced object is to be mapped to."
						}
					}
				}
			]
		},
		"CategorySchemeMapType":{
			"description":"CategorySchemeMapType defines the structure of a map which identifies relationships between categories in different category schemes. Unless the artefact is returned as a stub, it must contain the 'source' and 'target' properties.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableType"
				},
				{
					"properties":{
						"itemMaps":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/SingleValueMappingType"
							}
						},
						"source":{
							"$ref":"#/definitions/CategorySchemeReferenceType",
							"description":"Urn reference to a concept scheme object."
						},
						"target":{
							"$ref":"#/definitions/CategorySchemeReferenceType",
							"description":"Urn reference to a concept scheme object."
						}
					}
				}
			]
		},
		"CategorySchemeType":{
			"description":"CategorySchemeType describes the structure of a category scheme. A category scheme is the descriptive information for an arrangement or division of categories into groups based on characteristics, which the objects have in common. This provides for a simple, leveled hierarchy or categories.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableTypeWithNCNameID"
				},
				{
					"properties":{
						"isPartial":{
							"type":"boolean",
							"description":"isPartial, if true, indicates that only the relevant portion of the category scheme is being communicated."
						},
						"categories":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/CategoryType",
								"description":"Category represents a set of nested categories which describe a simple classification hierarchy."
							}
						}
					}
				}
			]
		},
		"CategoryType":{
			"description":"CategoryType describes the details of a category. A category is defined as an item at any level in a classification. The Category element represents a set of nested categories which are child categories.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/NameableType"
				},
				{
					"properties":{
						"categories":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/CategoryType"
							}
						}
					},
					"required":[
						"id"
					]
				}
			]
		},
		"CodeDataType":{
			"description":"CodeDataType is a restriction of the basic data types that are applicable to codes. Although some of the higher level time period formats are perimitted, it should be noted that any value which contains time (which includes a time zone offset) is not allowable as a code identifier.",
			"type":"string",
			"enum":[
				"String",
				"Alpha",
				"AlphaNumeric",
				"Numeric",
				"BigInteger",
				"Integer",
				"Long",
				"Short",
				"Boolean",
				"URI",
				"Count",
				"InclusiveValueRange",
				"ExclusiveValueRange",
				"Incremental",
				"ObservationalTimePeriod",
				"StandardTimePeriod",
				"BasicTimePeriod",
				"GregorianTimePeriod",
				"GregorianYear",
				"GregorianYearMonth",
				"GregorianDay",
				"ReportingTimePeriod",
				"ReportingYear",
				"ReportingSemester",
				"ReportingTrimester",
				"ReportingQuarter",
				"ReportingMonth",
				"ReportingWeek",
				"ReportingDay",
				"Month",
				"MonthDay",
				"Day",
				"Duration"
			]
		},
		"CodeType":{
			"description":"CodeType describes the structure of a code. A code is defined as a language independent set of letters, numbers or symbols that represent a concept whose meaning is described in a natural language. Presentational information not present may be added through the use of annotations.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/NameableType"
				},
				{
					"properties":{
						"parent":{
							"$ref":"#/definitions/idType",
							"description":"Parent provides the ability to describe simple hierarchies within a single codelist, by referencing the id value of another code in the same codelist."
						}
					},
					"required":[
						"id"
					]
				}
			]
		},
		"CodedTextFormatType":{
			"description":"CodedTextFormatType is a restricted version of the SimpleComponentTextFormatType that only allows factets and text types applicable to codes. Although the time facets permit any value, an actual code identifier does not support the necessary characters for time. Therefore these facets should not contain time in their values.",
			"type":"object",
			"properties":{
				"dataType":{
					"$ref":"#/definitions/CodeDataType"
				},
				"isSequence":{
					"type":"boolean"
				},
				"interval":{
					"type":"integer"
				},
				"startValue":{
					"type":"integer"
				},
				"endValue":{
					"type":"integer"
				},
				"timeInterval":{
					"$ref":"#/definitions/duration"
				},
				"startTime":{
					"$ref":"#/definitions/StandardTimePeriodType"
				},
				"endTime":{
					"$ref":"#/definitions/StandardTimePeriodType"
				},
				"minLength":{
					"type":"integer",
					"minimum":1
				},
				"maxLength":{
					"type":"integer",
					"minimum":1
				},
				"minValue":{
					"type":"integer"
				},
				"maxValue":{
					"type":"integer"
				},
				"pattern":{
					"type":"string"
				}
			},
			"additionalProperties":false
		},
		"CodelistType":{
			"description":"CodelistType defines the structure of a codelist. A codelist is defined as a list from which some statistical concepts (coded concepts) take their values.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableTypeWithNCNameID"
				},
				{
					"properties":{
						"isPartial":{
							"type":"boolean",
							"description":"isPartial, if true, indicates that only the relevant portion of the codelist is being communicated. This is used in cases where a codelist is returned for a data structure in the context of a constraint."
						},
						"codes":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/CodeType",
								"description":"Code describes a code in a codelist. In addition to the identification and description of the code, basic presentational information is also available. Presentational information not present may be added through the use of annotations."
							}
						},
						"codelistExtensions":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/CodelistExtensionType",
								"description":"CodelistExtension allows for the extension of codelists by referencing the codelists to be extended and providing inclusion/exclusion rules for selecting the codes to extend. The order of these is important as it is indicates the order of precedence of the extended codelists for conflict resolution of codes. However, the prefix property can be used to ensure uniqueness of inherited codes in the extending codelist, in case conflicting codes must be included."
							}
						}
					}
				}
			]
		},
		"GeographicCodelistType":{
			"description":"GeographicCodelistType defines the sturcture of a geographic codelist. It comprises a set of GeoFeatureSetCodes, by adding a value in the Code that follows a pattern to represent a geo feature set. Unless the artefact is returned as a stub, it must contain the 'geoType' property.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableTypeWithNCNameID"
				},
				{
					"properties":{
						"isPartial":{
							"type":"boolean",
							"description":"isPartial, if true, indicates that only the relevant portion of the geographic codelist is being communicated."
						},
						"geoType":{
							"const":"GeographicCodelist"
						},
						"geoFeatureSetCodes":{
							"type":"array",
							"minItems":1,
							"items":{
								"allOf":[
									{
										"$ref":"#/definitions/CodeType"
									},
									{
										"required":[
											"value"
										],
										"properties":{
											"value":{
												"type":"string"
											}
										}
									}
								]
							}
						},
						"codelistExtensions":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/CodelistExtensionType",
								"description":"CodelistExtension allows for the extension of codelists by referencing the codelists to be extended and providing inclusion/exclusion rules for selecting the codes to extend. The order of these is important as it is indicates the order of precedence of the extended codelists for conflict resolution of codes. However, the prefix property can be used to ensure uniqueness of inherited codes in the extending codelist, in case conflicting codes must be included."
							}
						}
					}
				}
			]
		},
		"GeoGridCodelistType":{
			"description":"GeoGridCodelistType defines the structure of a geographic grid code list. These define a geographical grid composed of cells representing regular squared portions of the Earth. Unless the artefact is returned as a stub, it must contain the 'geoType' and 'gridDefinition' properties.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableTypeWithNCNameID"
				},
				{
					"properties":{
						"isPartial":{
							"type":"boolean",
							"description":"isPartial, if true, indicates that only the relevant portion of the geogrid codelist is being communicated."
						},
						"geoType":{
							"const":"GeoGridCodelist"
						},
						"gridDefinition":{
							"type":"string",
							"description":"Contains a regular expression string corresponding to the grid definition for the GeoGrid Codelist."
						},
						"geoGridCodes":{
							"type":"array",
							"minItems":1,
							"items":{
								"description":"GeoGridCode is a code that represents a geographic grid cell that belongs to a specific grid definition.",
								"allOf":[
									{
										"$ref":"#/definitions/CodeType"
									},
									{
										"required":[
											"geoCell"
										],
										"properties":{
											"geoCell":{
												"type":"string",
												"description":"The value used to assign the Code to one cell in the grid."
											}
										}
									}
								]
							}
						},
						"codelistExtensions":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/CodelistExtensionType",
								"description":"CodelistExtension allows for the extension of codelists by referencing the codelists to be extended and providing inclusion/exclusion rules for selecting the codes to extend. The order of these is important as it is indicates the order of precedence of the extended codelists for conflict resolution of codes. However, the prefix property can be used to ensure uniqueness of inherited codes in the extending codelist, in case conflicting codes must be included."
							}
						}
					}
				}
			]
		},
		"ValueListType":{
			"description":"ValueListType defines the structure of value list. These represent a closed set of values the can occur for a dimension, measure, or attribute. These may be values, or values with names and descriptions (similar to a codelist).",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableTypeWithNCNameID"
				},
				{
					"properties":{
						"valueItems":{
							"type":"array",
							"minItems":1,
							"items":{
								"description":"ValueItem represents a value item. A value must be provided, and a longer name and description can be provided to provide additiona meaning to the value (similar to a code in a code list).",
								"allOf":[
									{
										"$ref":"#/definitions/AnnotableType"
									},
									{
										"required":[
											"id"
										],
										"properties":{
											"id":{
												"type":"string"
											},
											"name":{
												"$ref":"#/definitions/localisedBestMatchText"
											},
											"names":{
												"$ref":"#/definitions/localisedText"
											},
											"description":{
												"$ref":"#/definitions/localisedBestMatchText"
											},
											"descriptions":{
												"$ref":"#/definitions/localisedText"
											}
										}
									}
								]
							}
						}
					}
				}
			]
		},
		"CodelistExtensionType":{
			"description":"CodelistExtensionType defines the structure of a codelist to be extended by the codelist defining the extension. It provides a reference to the extended codelist and selection criteria to indicate the codes to be included in the extending codelist.",
			"type":"object",
			"properties":{
				"prefix":{
					"type":"string",
					"description":"A reference to a codelist may contain a prefix. If a prefix is provided, this prefix will be applied to all the codes in the codelist before they are imported into the extended codelist."
				},
				"codelist":{
					"$ref":"#/definitions/CodelistReferenceType",
					"description":"Reference to a codelist object through a URN."
				},
				"inclusiveCodeSelection":{
					"$ref":"#/definitions/CodeSelectionType",
					"description":"Selection of codes from the referenced (extended) codelist to be included in the extending codelist."
				},
				"exclusiveCodeSelection":{
					"$ref":"#/definitions/CodeSelectionType",
					"description":"Selection of codes from the referenced (extended) codelist to be excluded in the extending codelist."
				}
			},
			"required":[
				"codelist"
			],
			"anyOf":[
				{
					
				},
				{
					"required":[
						"inclusiveCodeSelection"
					]
				},
				{
					"required":[
						"exclusiveCodeSelection"
					]
				}
			],
			"not":{
				"required":[
					"inclusiveCodeSelection",
					"exclusiveCodeSelection"
				]
			}
		},
		"CodeSelectionType":{
			"description":"CodeSelectionType defines the structure for code selection to be used as inclusive or exclusive extensions.",
			"type":"object",
			"anyOf":[
				{
					"required":[
						"wildcardedMemberValues"
					]
				},
				{
					"required":[
						"memberValues"
					]
				}
			],
			"properties":{
				"wildcardedMemberValues":{
					"type":"array",
					"uniqueItems":true,
					"minItems":1,
					"items":{
						"type":"string",
						"pattern":"^[A-Za-z0-9_@$-]+%?$",
						"description":"WildcardedMemberValue allows for an optional wildcard character ('%') at the end of an identifier."
					},
					"description":"A wildcard expression that is evaluated to determine codes selected for inclusion/exclusion."
				},
				"memberValues":{
					"type":"array",
					"uniqueItems":true,
					"minItems":1,
					"items":{
						"$ref":"#/definitions/MemberValueType",
						"description":"An explicit selection of a code from the codelist selected for inclusion/exclusion. If the extended list is hierarchical, this can indicate whether child codes are to be included."
					}
				}
			}
		},
		"MemberValueType":{
			"anyOf":[
				{
					"$ref":"#/definitions/idType"
				},
				{
					"type":"object",
					"properties":{
						"value":{
							"$ref":"#/definitions/idType"
						},
						"cascadeValues":{
							"$ref":"#/definitions/CascadeSelectionType"
						}
					},
					"required":[
						"value"
					]
				}
			]
		},
		"CascadeSelectionType":{
			"anyOf":[
				{
					"type":"boolean"
				},
				{
					"const":"excluderoot",
					"description":"ExcludeRootType is a single enumerated value that indciates that child values should be included, but that the actuall root should not."
				}
			]
		},
		"CodingTextFormatType":{
			"type":"object",
			"properties":{
				"dataType":{
					"$ref":"#/definitions/SimpleCodeDataType"
				},
				"isSequence":{
					"type":"boolean"
				},
				"interval":{
					"type":"integer"
				},
				"startValue":{
					"type":"integer",
					"minimum":1
				},
				"endValue":{
					"type":"integer",
					"minimum":1
				},
				"minLength":{
					"type":"integer",
					"minimum":1
				},
				"maxLength":{
					"type":"integer",
					"minimum":1
				},
				"minValue":{
					"type":"integer",
					"minimum":1
				},
				"maxValue":{
					"type":"integer",
					"minimum":1
				},
				"pattern":{
					"type":"string"
				}
			}
		},
		"ComputationType":{
			"description":"ComputationType describes a computation in a process.",
			"type":"object",
			"properties":{
				"localID":{
					"$ref":"#/definitions/idType"
				},
				"softwareLanguage":{
					"type":"string"
				},
				"softwarePackage":{
					"type":"string"
				},
				"softwareVersion":{
					"type":"string"
				},
				"annotations":{
					"$ref":"#/definitions/AnnotationsType"
				},
				"description":{
					"$ref":"#/definitions/localisedBestMatchText"
				},
				"descriptions":{
					"$ref":"#/definitions/localisedText"
				}
			},
			"required":[
				"description"
			]
		},
		"ConceptRepresentationType":{
			"description":"ConceptRepresentationType defines the core representation that are allowed for a concept. The text format allowed for a concept is that which is allowed for any non-target object component.",
			"type":"object",
			"oneOf":[
				{
					"properties":{
						"enumeration":{
							"$ref":"#/definitions/AnyCodelistReferenceType",
							"description":"Urn reference to a codelist which enumerates the possible values that can be used as the representation of this concept."
						},
						"enumerationFormat":{
							"$ref":"#/definitions/CodedTextFormatType"
						},
						"minOccurs":{
							"type":"integer",
							"minimum":0,
							"default":1,
							"description":"The minOccurs attribute indicates the minimum number of value that must be reported for the component."
						},
						"maxOccurs":{
							"$ref":"#/definitions/OccurenceType",
							"default":1,
							"description":"The maxOccurs attribute indicates the maximum number of values that can be reported for the component."
						}
					},
					"required":[
						"enumeration"
					]
				},
				{
					"properties":{
						"format":{
							"$ref":"#/definitions/BasicComponentTextFormatType"
						},
						"minOccurs":{
							"type":"integer",
							"minimum":0,
							"default":1,
							"description":"The minOccurs attribute indicates the minimum number of value that must be reported for the component."
						},
						"maxOccurs":{
							"$ref":"#/definitions/OccurenceType",
							"default":1,
							"description":"The maxOccurs attribute indicates the maximum number of values that can be reported for the component."
						}
					},
					"required":[
						"format"
					]
				}
			]
		},
		"ConceptSchemeMapType":{
			"description":"ConceptSchemeMapType defines the structure of a map which identifies relationships between concepts in different concept schemes. Unless the artefact is returned as a stub, it must contain the 'source' and 'target' properties.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableType"
				},
				{
					"properties":{
						"itemMaps":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/SingleValueMappingType"
							}
						},
						"source":{
							"$ref":"#/definitions/ConceptSchemeReferenceType",
							"description":"Urn reference to a concept scheme object."
						},
						"target":{
							"$ref":"#/definitions/ConceptSchemeReferenceType",
							"description":"Urn reference to a concept scheme object."
						}
					}
				}
			]
		},
		"SingleValueMappingType":{
			"description":"SingleValueMappingType defines a mapping with a single source and optional target.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/AnnotableType"
				},
				{
					"properties":{
						"sourceValue":{
							"$ref":"#/definitions/MappedValueType",
							"description":"There should be a source value for each source represention (e.g. codelist, data type). Source values can be pattern matched by using regular expression or substrings using start/end indexes."
						},
						"targetValue":{
							"type":"string",
							"description":"The target value(s) is always an absolute string. However, if source value is a regular expression, the target value can output the capture group from the source."
						},
						"validFrom":{
							"type":"string",
							"format":"date-time"
						},
						"validTo":{
							"type":"string",
							"format":"date-time"
						}
					}
				}
			],
			"required":[
				"sourceValue"
			]
		},
		"ConceptSchemeType":{
			"description":"ConceptSchemeType describes the structure of a concept scheme. A concept scheme is the descriptive information for an arrangement or division of concepts into groups based on characteristics, which the objects have in common. It contains a collection of concept definitions, that may be arranged in simple hierarchies.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableTypeWithNCNameID"
				},
				{
					"properties":{
						"isPartial":{
							"type":"boolean",
							"description":"isPartial, if true, indicates that only the relevant portion of the concept scheme is being communicated."
						},
						"concepts":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/ConceptType",
								"description":"Concept describes the details of a concept within a concept scheme."
							}
						}
					}
				}
			]
		},
		"ConceptType":{
			"description":"ConceptType describes the details of a concept. A concept is defined as a unit of knowledge created by a unique combination of characteristics. If a concept does not specify a TextFormat or a core representation, then the representation of the concept is assumed to be represented by any set of valid characters (corresponding to the string datatype).",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/NameableTypeWithNCNameID"
				},
				{
					"properties":{
						"coreRepresentation":{
							"$ref":"#/definitions/ConceptRepresentationType"
						},
						"isoConceptReference":{
							"type":"object",
							"properties":{
								"conceptAgency":{
									"type":"string"
								},
								"conceptSchemeID":{
									"type":"string"
								},
								"conceptID":{
									"type":"string"
								}
							},
							"required":[
								"conceptAgency",
								"conceptSchemeID",
								"conceptID"
							],
							"description":"Provides a reference to an ISO 11179 concept."
						},
						"parent":{
							"$ref":"#/definitions/SingleNCNameIDType",
							"description":"ID of a local concept. Parent captures the semantic relationships between concepts which occur within a single concept scheme. This identifies the concept of which the current concept is a qualification (in the ISO 11179 sense) or subclass."
						}
					},
					"required":[
						"id"
					]
				}
			]
		},
		"DataConstraintAttachmentType":{
			"description":"DataConstraintAttachmentType describes a collection of references to constrainable artefacts related to data.",
			"type":"object",
			"oneOf":[
				{
					"required":[
						"dataProvider"
					],
					"properties":{
						"dataProvider":{
							"$ref":"#/definitions/DataProviderReferenceType",
							"description":"dataProvider is a urn reference to a the provider of the data/metadata set to which the constraint is attached. If this is used, then only the release calendar is relevant.."
						}
					}
				},
				{
					"required":[
						"simpleDataSources"
					],
					"properties":{
						"simpleDataSources":{
							"type":"array",
							"uniqueItems":true,
							"minItems":1,
							"items":{
								"description":"SimpleDataSource describes a simple data source, which is a URL of a SDMX-ML data or metadata message. Multiple instance can only be used if they have the same underlying structure.",
								"$ref":"#/definitions/uri"
							}
						}
					}
				},
				{
					"required":[
						"dataStructures"
					],
					"properties":{
						"dataStructures":{
							"type":"array",
							"uniqueItems":true,
							"minItems":1,
							"items":{
								"$ref":"#/definitions/DataStructureReferenceType",
								"description":"Urn reference to a data structure definition object to which the constraint is attached. A constraint which is attached to more than one data structure must only express key sets and/or cube regions where the identifiers of the dimensions are common across all structures to which the constraint is attached."
							}
						},
						"queryableDataSources":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/QueryableDataSourceType",
								"description":"queryableDataSource describes a queryable data source to which the constraint is attached."
							}
						}
					}
				},
				{
					"required":[
						"dataflows"
					],
					"properties":{
						"dataflows":{
							"type":"array",
							"uniqueItems":true,
							"minItems":1,
							"items":{
								"$ref":"#/definitions/DataflowReferenceType",
								"description":"Urn reference to a dataflow object to which the constraint is attached. A constraint can be attached to more than one dataflow, and the dataflows do not necessarily have to be usages of the same data structure. However, a constraint which is attached to more than one data structure must only express key sets and/or cube regions where the identifiers of the dimensions are common across all structures to which the constraint is attached."
							}
						},
						"queryableDataSources":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/QueryableDataSourceType",
								"description":"queryableDataSource describes a queryable data source to which the constraint is attached."
							}
						}
					}
				},
				{
					"required":[
						"provisionAgreements"
					],
					"properties":{
						"provisionAgreements":{
							"type":"array",
							"uniqueItems":true,
							"minItems":1,
							"items":{
								"$ref":"#/definitions/ProvisionAgreementReferenceType",
								"description":"Urn reference to a provision agreement to which the constraint is attached. A constraint can be attached to more than one provision agreement, and the provision agreements do not necessarily have to be references structure usages based on the same structure. However, a constraint which is attached to more than one provision agreement must only express key sets and/or cube/target regions where the identifier of the components are common across all structures to which the constraint is attached."
							}
						},
						"queryableDataSources":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/QueryableDataSourceType",
								"description":"queryableDataSource describes a queryable data source to which the constraint is attached."
							}
						}
					}
				}
			]
		},
		"DataConstraintType":{
			"description":"DataConstraintType defines the structure of a data constraint. A data constraint can specify either the available set of keys (DataKeySet) or set of component values (CubeRegion) in a data source, or the allowable keys that can be constructed from a data structure definition. Multiple such constraints may be present for a constrained artefact. For instance, there may be a constraing that specifies the values allowed for the data source (role is 'Allowed') which can be used for validation or for constructing a partial code list, whilst another constraing can specify the actual content of a data source (role is 'Actual'). Unless the artefact is returned as a stub, it must contain the 'role' property.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableType"
				},
				{
					"properties":{
						"role":{
							"$ref":"#/definitions/ConstraintRoleType",
							"description":"The role attribute indicates whether this constraint states what data is actually present for the constraint attachment, or if it defines what content is allowed."
						},
						"constraintAttachment":{
							"$ref":"#/definitions/DataConstraintAttachmentType",
							"description":"DataConstraint specifies a sub set of the definition of the allowable or available content of a data set in terms of the content or in terms of the set of key combinations."
						},
						"releaseCalendar":{
							"$ref":"#/definitions/ReleaseCalendarType",
							"description":"ReleaseCalendar defines dates on which the constrained data is to be made available."
						},
						"dataKeySets":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/DataKeySetType",
								"description":"DataKeySet defines a full, distinct set of dimension values and the attribute values associated with the key."
							}
						},
						"cubeRegions":{
							"type":"array",
							"minItems":1,
							"maxItems":2,
							"items":{
								"$ref":"#/definitions/CubeRegionType",
								"description":"CubeRegion defines a slice of the data set (dimensions and attribute values) for the constrained artefacet. A set of either included or excluded regions can be described."
							}
						}
					}
				}
			]
		},
		"ConstraintRoleType":{
			"description":"ConstraintRoleType defines a list of roles for a content constraint. A constraint can state which data is present or which content is allowed for the constraint attachment. Allowed: The constraint contains the allowed values for attachable object. Actual: The constraints contains the actual data present for the attachable object.",
			"type":"string",
			"enum":[
				"Allowed",
				"Actual"
			]
		},
		"DataConsumerSchemeType":{
			"description":"DataConsumerSchemeType defines a type of organisation scheme which contains only data consumers. The data consumer scheme maintained by a particular maintenance agency is always provided a fixed identifier and version, and is never final. Therefore, consumers can be added or removed without have to version the scheme. This scheme has no hierarchy, meaning that no organisation may define a relationship with another organisation in the scheme.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableWithoutVersionType"
				},
				{
					"properties":{
						"id":{
							"const":"DATA_CONSUMERS"
						},
						"isPartial":{
							"type":"boolean",
							"description":"isPartial, if true, indicates that only the relevant portion of the data consumer scheme is being communicated."
						},
						"dataConsumers":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/DataConsumerType",
								"description":"DataConsumer describes an organisation using data as input for further processing."
							}
						}
					}
				}
			]
		},
		"DataConsumerType":{
			"description":"DataConsumerType defines the structure of a data consumer description. The contacts defined for the organisation are specific to the data consumer role the organisation is serving.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/NameableType"
				},
				{
					"properties":{
						"contacts":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/contactType"
							}
						}
					},
					"required":[
						"id"
					]
				}
			]
		},
		"DataKeySetType":{
			"description":"DataKeySetType defines a collection of full or partial data keys (dimension values).",
			"type":"object",
			"properties":{
				"isIncluded":{
					"type":"boolean",
					"description":"The isIncluded attribute indicates whether the keys defined in this key set are inclusive or exclusive to the constraint."
				},
				"keys":{
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/DataKeyType",
						"description":"Key contains a set of dimension values which identify a full set of data."
					}
				}
			},
			"required":[
				"isIncluded",
				"keys"
			]
		},
		"DataProviderSchemeType":{
			"description":"DataProviderSchemeType defines a type of organisation scheme which contains only data providers. The data provider scheme maintained by a particular maintenance agency is always provided a fixed identifier and version, and is never final. Therefore, providers can be added or removed without have to version the scheme. This scheme has no hierarchy, meaning that no organisation may define a relationship with another organisation in the scheme.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableWithoutVersionType"
				},
				{
					"properties":{
						"id":{
							"const":"DATA_PROVIDERS"
						},
						"isPartial":{
							"type":"boolean",
							"description":"isPartial, if true, indicates that only the relevant portion of the data provider scheme is being communicated."
						},
						"dataProviders":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/DataProviderType",
								"description":"DataProvider describes an organisation that produces data."
							}
						}
					}
				}
			]
		},
		"MetadataProviderSchemeType":{
			"description":"MetadataProviderSchemeType defines a type of organisation scheme which contains only metadata providers. The metadata provider scheme maintained by a particular maintenance agency is always provided a fixed identifier and is never versioned. Therefore, providers can be added or removed without have to version the scheme. This scheme has no hierarchy, meaning that no organisation may define a relationship with another organisation in the scheme.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableWithoutVersionType"
				},
				{
					"properties":{
						"id":{
							"const":"METADATA_PROVIDERS"
						},
						"isPartial":{
							"type":"boolean",
							"description":"isPartial, if true, indicates that only the relevant portion of the metadata provider scheme is being communicated."
						},
						"metadataProviders":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/MetadataProviderType",
								"description":"MetadataProvider describes an organisation that produces metadata."
							}
						}
					}
				}
			]
		},
		"DataProviderType":{
			"description":"DataProviderType defines the structure of a data provider description. The contacts defined for the organisation are specific to the data provider role the organisation is serving.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/NameableType"
				},
				{
					"properties":{
						"contacts":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/contactType"
							}
						}
					},
					"required":[
						"id"
					]
				}
			]
		},
		"MetadataProviderType":{
			"description":"MetadataProviderType defines the structure of a metadata provider description. The contacts defined for the organisation are specific to the metadata provider role the organisation is serving.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/NameableType"
				},
				{
					"properties":{
						"contacts":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/contactType"
							}
						}
					},
					"required":[
						"id"
					]
				}
			]
		},
		"DataStructureComponentsType":{
			"description":"DataStructureComponentsType describes the structure of the grouping to the sets of components that have a defined structural role in the data structure definition. At a minimum at least one dimension must be defined.",
			"type":"object",
			"properties":{
				"attributeList":{
					"$ref":"#/definitions/AttributeListType",
					"description":"AttributeList describes the attribute descriptor for the data structure definition. It is a collection of metadata concepts that define the attributes of the data structure definition."
				},
				"dimensionList":{
					"$ref":"#/definitions/DimensionListType",
					"description":"DimensionList describes the key descriptor for the data structure definition. It is an ordered set of metadata concepts that, combined, classify a statistical series, such as a time series, and whose values, when combined (the key) in an instance such as a data set, uniquely identify a specific series."
				},
				"groups":{
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/GroupType",
						"description":"Group describes a group descriptor in a data structure definition. It is a set metadata concepts (and possibly their values) that define a partial key derived from the key descriptor in a data structure definition."
					}
				},
				"measureList":{
					"$ref":"#/definitions/MeasureListType",
					"description":"MeasureList describes the measure descriptor for a data structure."
				}
			},
			"required":[
				"dimensionList"
			]
		},
		"DataStructureType":{
			"description":"DataStructureType defines the structure for a data structure definition. A data structure definition is defined as a collection of metadata concepts, their structure and usage when used to collect or disseminate data.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableType"
				},
				{
					"properties":{
						"dataStructureComponents":{
							"$ref":"#/definitions/DataStructureComponentsType",
							"description":"DataStructureComponents defines the grouping of the sets of metadata concepts that have a defined structural role in the data structure definition. Note that for any component or group defined in a data structure definition, its id must be unique. This applies to the identifiers explicitly defined by the components as well as those inherited from the concept identity of a component. For example, if two dimensions take their identity from concepts with same identity (regardless of whether the concepts exist in different schemes) one of the dimensions must be provided a different explicit identifier. Although there are XML schema constraints to help enforce this, these only apply to explicitly assigned identifiers. Identifiers inherited from a concept from which a component takes its identity cannot be validated against this constraint. Therefore, systems processing data structure definitions will have to perform this check outside of the XML validation. There are also two reserved identifiers in a data structure definition; TIME_PERIOD, and REPORTING_YEAR_START_DAY. These identifiers may not be used outside of their respective defintions (TimeDimension and ReportingYearStartDay). This applies to both the explicit identifiers that can be assigned to the components or groups as well as an identifier inherited by a component from its concept identity. For example, if an ordinary dimension (i.e. not the time dimension) takes its concept identity from a concept with the identifier TIME_PERIOD, that dimension must provide a different explicit identifier."
						},
						"metadata":{
							"$ref":"#/definitions/MetadataStructureReferenceType",
							"description":"A data structure definition may be related to a metadata structure definition in order to use its metadata attributes as part of the data. Note that referenced metadata can also contain nested metadata attributes. By default all metadata attributes can be associated at any level of the data. However, a metadata attribute usage can be used to provide a specific attribute relationshp for a given metadata attribute."
						}
					}
				}
			]
		},
		"DataflowType":{
			"description":"DataflowType describes the structure of a data flow. A data flow is defined as the structure of data that will provided for different reference periods. If this type is not referenced externally, then a reference to a data structure definition must be provided.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableType"
				},
				{
					"properties":{
						"structure":{
							"$ref":"#/definitions/DataStructureReferenceType",
							"description":"Urn reference to the data structure definition which defines the structure of all data for this flow."
						}
					}
				}
			]
		},
		"DimensionListType":{
			"description":"DimensionListType describes the key descriptor for a data structure definition. The order of the declaration of child dimensions is significant: it is used to describe the order in which they will appear in data formats for which key values are supplied in an ordered fashion (exclusive of the time dimension, which is not represented as a member of the ordered key). Any data structure definition which uses the time dimension should also declare a frequency dimension, conventionally the first dimension in the key (the set of ordered non-time dimensions). If is not necessary to assign a time dimension, as data can be organised in any fashion required.",
			"type":"object",
			"allOf":[
				{
					"properties":{
						"id":{
							"const":"DimensionDescriptor"
						},
						"links":{
							"$ref":"#/definitions/links",
							"description":"Links field is an array of link objects. Also used to specify the URI or the URN to itself. If appropriate, a collection of links to additional external resources."
						}
					}
				},
				{
					"$ref":"#/definitions/AnnotableType"
				},
				{
					"properties":{
						"dimensions":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/DimensionType",
								"description":"Dimension describes the structure of a dimension, which is defined as a statistical concept used (most probably together with other statistical concepts) to identify a statistical series, such as a time series, e.g. a statistical concept indicating certain economic activity or a geographical reference area."
							}
						},
						"timeDimension":{
							"$ref":"#/definitions/TimeDimensionType",
							"description":"TimeDimension is a special dimension which designates the period in time in which the data identified by the full series key applies."
						}
					}
				}
			]
		},
		"DimensionType":{
			"description":"DimensionType describes the structure of an ordinary dimension, which is defined as a statistical concept used (most probably together with other statistical concepts) to identify a statistical series, such as a time series, e.g. a statistical concept indicating certain economic activity or a geographical reference area. The dimension takes its semantic, and in some cases it representation, from its concept identity. A dimension can be coded by referencing a code list from its coded local representation. It can also specify its text format, which is used as the representation of the dimension if a coded representation is not defined. Neither the coded or uncoded representation are necessary, since the dimension may take these from the referenced concept.",
			"type":"object",
			"required":[
				"conceptIdentity"
			],
			"allOf":[
				{
					"$ref":"#/definitions/IdentifiableTypeWithNCNameID"
				},
				{
					"properties":{
						"position":{
							"description":"The order of the dimensions in the key descriptor (DimensionList element) defines the order of the dimensions in the data structure. This position attribute explicitly specifies the position of the dimension in the data structure, starting at 0. It is optional and if specified must be consistent with the position of the dimension in the key descriptor.",
							"type":"integer",
							"minimum":0
						},
						"conceptIdentity":{
							"$ref":"#/definitions/ConceptReferenceType",
							"description":"Urn reference to a concept where the identification of the concept scheme which defines it is contained in another context."
						},
						"conceptRoles":{
							"description":"ConceptRoles references concepts which define roles which this dimension serves. If the concept from which the attribute takes its identity also defines a role the concept serves, then the isConceptRole indicator can be set to true on the concept identity rather than repeating the reference here.",
							"type":"array",
							"minItems":1,
							"uniqueItems":true,
							"items":{
								"$ref":"#/definitions/ConceptReferenceType",
								"description":"Urn reference to a concept where the identification of the concept scheme which defines it is contained in another context."
							}
						},
						"localRepresentation":{
							"$ref":"#/definitions/SimpleDataStructureRepresentationType"
						}
					}
				}
			]
		},
		"GroupType":{
			"description":"GroupType describes the structure of a group descriptor in a data structure definition. A group may consist of a of partial key, or collection of distinct cube regions or key sets to which attributes may be attached. The purpose of a group is to specify attributes values which have the same value based on some common dimensionality. All groups declared in the data structure must be unique - that is, you may not have duplicate partial keys. All groups must be given unique identifiers.",
			"type":"object",
			"required":[
				"id"
			],
			"allOf":[
				{
					"$ref":"#/definitions/IdentifiableType"
				},
				{
					"properties":{
						"groupDimensions":{
							"type":"array",
							"minItems":1,
							"uniqueItems":true,
							"items":{
								"$ref":"#/definitions/NCNameIDType",
								"description":"Array of id's of dimensions defined in the key descriptor (DimensionList). Although it is conventional to declare dimensions in the same order as they are declared in the ordered key, there is no requirement to do so - the ordering of the values of the key are taken from the order in which the dimensions are declared. Note that the id of a dimension may be inherited from its underlying concept - therefore this reference value may actually be the id of the concept."
							}
						}
					}
				}
			]
		},
		"HierarchicalCodeType":{
			"description":"HierarchicalCodeType describes the structure of a hierarchical code. A hierarchical code provides for a reference to a code that is referenced within the hierarchical code list via either a complete reference to a code through either a URN or full set of reference fields. Codes are arranged in a hierarchy by this reference. Note that it is possible to reference a single code such that it has multiple parents within the hierarchy. Further, the hierarchy may or may not be a leveled one.",
			"type":"object",
			"required":[
				"id",
				"code"
			],
			"allOf":[
				{
					"$ref":"#/definitions/IdentifiableType",
					"description":"The id attribute allows for an id to be assigned to the use of the particular code at that specific point in the hierarchy. This value is unique within the hierarchy being created, and is used to map the hierarchy against external structures."
				},
				{
					"properties":{
						"validFrom":{
							"type":"string",
							"format":"date-time"
						},
						"validTo":{
							"type":"string",
							"format":"date-time"
						},
						"code":{
							"$ref":"#/definitions/CodeReferenceType",
							"description":"Code provides a complete, explicit reference to the codelist and a code through its URN."
						},
						"hierarchicalCodes":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/HierarchicalCodeType",
								"description":"HierarchicalCode is used to nest referenced codes into a value based hierarchy."
							}
						},
						"level":{
							"$ref":"#/definitions/idType",
							"description":"Level references a formal level defined within the hierarchy which defines this hierarchical code. This is only necessary if the nesting depth of the hierarchical code does not correspond to the nesting depth of the level to which it belongs (i.e. the hieararchical code is to skip down a level). Otherwise, the code is assumed to exist at the level in which the nesting depth of the level matches the nesting depth of the code."
						}
					}
				}
			]
		},
		"HierarchyType":{
			"description":"The Hierarchy is an abstract type that provides for a classification structure of referenced codes arranged in levels of detail from the broadest to the most detailed level. The levels in which the code exist can be formal or informal. Unless the artefact is returned as a stub, it must contain the 'hierarchicalCodes' and 'hasFormalLevels' properties.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableType"
				},
				{
					"properties":{
						"level":{
							"$ref":"#/definitions/LevelType",
							"description":"In a formally leveled hierarchy, Level describes a group of codes which are characterised by homogeneous coding, and where the parent of each code in the group is at the same higher level of the hierarchy. In a value based hierarchy Level describes information about the codes at the specified nesting level. This structure is recursive to indicate the hierarchy of the levels."
						},
						"hierarchicalCodes":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/HierarchicalCodeType",
								"description":"HierarchicalCode is used to assemble the codes from the codelist(s) referenced into a hierarchy."
							}
						},
						"hasFormalLevels":{
							"type":"boolean",
							"description":"If “true”, this indicates a hierarchy where the structure is arranged in levels of detail from the broadest to the most detailed level. If “false”, this indicates a hierarchy structure where the items in the hierarchy have no formal level structure."
						}
					}
				}
			]
		},
		"HierarchyAssociationType":{
			"description":"HierarchyAssociationType defines the structure of a hiearchy association, which links a hierarchy with and identifiable object in the context of another object (e.g. a dimension within the context of a dataflow). Unless the artefact is returned as a stub, it must contain the 'linkedHierarchy' and 'linkedObject' properties.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableType"
				},
				{
					"properties":{
						"linkedHierarchy":{
							"$ref":"#/definitions/HierarchyReferenceType",
							"description":"The associated hierarchy defined by a complete, explicit reference through its URN."
						},
						"linkedObject":{
							"$ref":"#/definitions/urn",
							"description":"Associates the Identifiable Artefact that needs the Hierarchy."
						},
						"contextObject":{
							"$ref":"#/definitions/urn",
							"description":"The context within which the association is performed."
						}
					}
				}
			]
		},
		"CustomTypeSchemeType":{
			"description":"CustomTypeSchemeType defines a collection of custom types that are used in transformations. Unless the artefact is returned as a stub, it must contain the 'vtlVersion' property.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableType"
				},
				{
					"properties":{
						"isPartial":{
							"type":"boolean",
							"description":"isPartial, if true, indicates that only the relevant portion of the custom type scheme is being communicated."
						},
						"vtlVersion":{
							"type":"string"
						},
						"customTypes":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/CustomTypeType",
								"description":"CustomType details a custom type within a custom type scheme."
							}
						}
					}
				}
			]
		},
		"CustomTypeType":{
			"description":"CustomTypeType defines the structure of a custom type. A custom type specifies a custom conversion for a VTL scalar type to a resulting data type. This conversion overrides the default conversion.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/NameableType"
				},
				{
					"properties":{
						"vtlScalarType":{
							"type":"string",
							"description":"Identifies the VTL scalar type that is to be converted to an resulting output data type."
						},
						"dataType":{
							"anyOf":[
								{
									"type":"string",
									"description":"String value for other data types"
								},
								{
									"$ref":"#/definitions/SimpleDataType",
									"description":"SDMX simple data type enumeration value"
								}
							],
							"description":"Identifies the resulting output data type the VTL scalar type is to be converted to. If this is an SDMX data type, it must use the proper SimpleDataType enumeration value. For all other data types, a string value can be used to identify the type."
						},
						"vtlLiteralFormat":{
							"type":"string",
							"description":"The format in which the literals of the VTL scalar type are expressed in the transformations. This is only needed if the format is different than the output format expressed by means of the VTL type."
						},
						"outputFormat":{
							"type":"string",
							"description":"The format the VTL scalar type has to assume (e.g. YYYY-MM-DD; see VTL specifications), both for the literals in the VTL expressions and for the conversion to the output."
						},
						"nullValue":{
							"type":"string",
							"description":"The value to be produced in the output of the conversion when a component has a null value."
						}
					},
					"required":[
						"id",
						"vtlScalarType",
						"dataType"
					]
				}
			]
		},
		"VtlMappingSchemeType":{
			"description":"VtlMappingSchemeType defines a set of mappings between SDMX and VTL.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableType"
				},
				{
					"properties":{
						"isPartial":{
							"type":"boolean",
							"description":"isPartial, if true, indicates that only the relevant portion of the vtl mapping scheme is being communicated."
						},
						"vtlMappings":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/VtlMappingType",
								"description":"VtlMapping details a mapping between SDMX and VTL transformation."
							}
						}
					}
				}
			]
		},
		"VtlMappingType":{
			"description":"VtlMappingType defines the structure of a single mapping between the reference to a SDMX artefact made from VTL transformations, rulesets, user defined operators and the corresponding SDMX structure identifier. These are used to assign an alternative names to SDMX Dataflows, Codelists, Concept Schemes, or Concepts. Although are distinct sub-classes in the Information Model, this structure serves to express them all. The references SDMX artefact serves to distinguish which type of sub-class (VtlDatflowMapping or VtlCodelistMapping, or VtlConceptMapping) is being described. When this is used to assign an alias for a SDMX Dataflow, this can also be used to indicate the methods used to convert the data structure from SDMX to VTL and vice-versa. Finally, this can be used to override the deault Basic mapping methods used for Dataflows by utilizing the GenericDataflow element in place of a reference to a specific Dataflow.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/NameableType"
				},
				{
					"oneOf":[
						{
							"oneOf":[
								{
									"required":[
										"dataflow"
									],
									"properties":{
										"dataflow":{
											"$ref":"#/definitions/DataflowReferenceType",
											"description":"A reference to the SDMX Dataflow that the mapping is defined for. This is used to create a VtlDataflowMapping. In this case, it is possible to specify the mapping details to and from VTL."
										}
									}
								},
								{
									"required":[
										"genericDataflow"
									],
									"properties":{
										"genericDataflow":{
											"$ref":"#/definitions/EmptyType",
											"description":"Indicates that the ToVtlMapping and FromVtlMapping are the default mapping methods to be applied, overriding the Basic methods if necessary. The mapping methods in this case would be applied to any dataflows that are not explicitly defined in other VtlMappings."
										}
									}
								}
							],
							"properties":{
								"toVtlMapping":{
									"$ref":"#/definitions/ToVtlMappingType",
									"description":"Describes the mapping from a SDMX dataflow to a VTL data structure."
								},
								"fromVtlMapping":{
									"$ref":"#/definitions/FromVtlMappingType",
									"description":"Describes the mapping to a SDMX dataflow from a VTL data structure."
								}
							}
						},
						{
							"required":[
								"codelist"
							],
							"properties":{
								"codelist":{
									"$ref":"#/definitions/CodelistReferenceType",
									"description":"A reference to the SDMX Codelist that the mapping is defined for. This is used to create a VtlCodelistMapping."
								}
							}
						},
						{
							"required":[
								"concept"
							],
							"properties":{
								"concept":{
									"$ref":"#/definitions/ConceptReferenceType",
									"description":"A reference to the SDMX Concept that the mapping is defined for. This is used to create a VtlConceptMapping."
								}
							}
						}
					]
				},
				{
					"properties":{
						"alias":{
							"type":"string",
							"description":"The alias used to refer to the reference SDMX artefact in the transformations. This must be unique within the mapping scheme in which it is defined."
						}
					},
					"required":[
						"id",
						"alias"
					]
				}
			]
		},
		"ToVtlMappingType":{
			"description":"ToVtlMappingType defines the mapping method and filter used when mapping from SDMX to VTL.",
			"type":"object",
			"properties":{
				"toVtlSubSpace":{
					"$ref":"#/definitions/SpaceKeyType",
					"description":"Identfies a sub space of the mapped dataflow that the mapping applies to. This is a collection of references to the dimensions that make up the space."
				},
				"method":{
					"anyOf":[
						{
							"type":"string",
							"description":"A simple string type that allows for other mapping methods."
						},
						{
							"const":"Basic",
							"description":"The default mapping method. See Section 6 SDMX Standards ('SDMX Technical Notes'), 10.3.3.1 ('Basic Mapping')."
						},
						{
							"const":"Pivot",
							"description":"Method for mapping multi-measure data. See Section 6 SDMX Standards ('SDMX Technical Notes'), 10.3.3.2 ('Pivot Mapping')."
						},
						{
							"const":"Basic-A2M",
							"description":"The basic mapping method, using attributes to measures. See Section 6 SDMX Standards ('SDMX Technical Notes'), 10.3.3.3 ('From SDMX DataAttributes to VTL Measures')."
						},
						{
							"const":"Pivot-A2M",
							"description":"The pivot mapping method, using attributes to measures. See Section 6 SDMX Standards ('SDMX Technical Notes'), 10.3.3.3 ('From SDMX DataAttributes to VTL Measures')."
						}
					],
					"description":"The mapping method used when mapping from SDMX to VTL. This is typically a StandardToVtlMappingMethodType, but can be any other value to allow for non-standard methods. The implied default is Basic."
				}
			}
		},
		"SpaceKeyType":{
			"description":"SpaceKey defines the structure of a super- or sub- space for a SDMX Dataflow. It is a collection of references to the dimensions that make up the space.",
			"type":"object",
			"properties":{
				"keys":{
					"type":"array",
					"uniqueItems":true,
					"minItems":1,
					"items":{
						"$ref":"#/definitions/SingleNCNameIDType",
						"description":"A reference to a dimension by its identifier."
					}
				}
			}
		},
		"FromVtlMappingType":{
			"description":"FromVtlMappingType defines the mapping method and filter used when mapping from VTL to SDMX.",
			"type":"object",
			"properties":{
				"fromVtlSuperSpace":{
					"$ref":"#/definitions/SpaceKeyType",
					"description":"Identfies a super space of the mapped dataflow that the mapping applies to. This is a collection of references to the dimensions that make up the space."
				},
				"method":{
					"anyOf":[
						{
							"type":"string",
							"description":"A simple string type that allows for other mapping methods."
						},
						{
							"const":"Basic",
							"description":"The default mapping method, applicable only when the VLT data structure has just one measure component. See Section 6 SDMX Standards ('SDMX Technical Notes'), 10.3.4.1 ('Basic Mapping')."
						},
						{
							"const":"Unpivot",
							"description":"The mapping method to be used when the VTL data structure has more than one measure component. See Section 6 SDMX Standards ('SDMX Technical Notes'), 10.3.4.2 ('Unpivot Mapping')."
						},
						{
							"const":"M2A",
							"description":"Mapping of multi-measure VTL where on measure is mapped to the SDMX primary measure and the remaining measures are mapped as data attributes. See Section 6 SDMX Standards ('SDMX Technical Notes'), 10.3.4.3 ('From VTL Measures to SDMX DataAttributes')."
						}
					],
					"description":"The mapping method used when mapping from VTL to SDMX. This is typically a StandardFromVtlMappingMethodType, but can be any other value to allow for non-standard methods. The implied default is Basic for single-measure VTL data structures and Unpivot for multi-meausre VTL data structures."
				}
			}
		},
		"NamePersonalisationSchemeType":{
			"description":"NamePersonalisationSchemeType defines a set of personalisations of VTL standard names that are used in a set of transformations. Unless the artefact is returned as a stub, it must contain the 'vtlVersion' property.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableType"
				},
				{
					"properties":{
						"isPartial":{
							"type":"boolean",
							"description":"isPartial, if true, indicates that only the relevant portion of the name personalisation scheme is being communicated."
						},
						"vtlVersion":{
							"type":"string"
						},
						"namePersonalisations":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/NamePersonalisationType",
								"description":"NamePersonalisation details a name personalisation that is used in a transformation."
							}
						}
					}
				}
			]
		},
		"NamePersonalisationType":{
			"description":"NamePersonalisationType defines the structure of a name personalisation. A name personalisation is is used in place of a standard VTL name in some VTL operations.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/NameableType"
				},
				{
					"properties":{
						"vtlDefaultName":{
							"type":"string",
							"description":"Provides the VTL standard name that is being personalised."
						},
						"personalisedName":{
							"type":"string",
							"description":"Provides the personalised name that is used in place of the VTL standard name in the transformation expressions."
						},
						"vtlArtefact":{
							"type":"string",
							"description":"Identifies the type of VTL model artefact that is being personalised. In VTL 2.0, this is valuedomain or variable."
						}
					},
					"required":[
						"id",
						"vtlDefaultName",
						"personalisedName",
						"vtlArtefact"
					]
				}
			]
		},
		"RulesetSchemeType":{
			"description":"RulesetSchemeType defines a collection of rulesets that are used in transformations. Unless the artefact is returned as a stub, it must contain the 'vtlVersion' property.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableType"
				},
				{
					"properties":{
						"isPartial":{
							"type":"boolean",
							"description":"isPartial, if true, indicates that only the relevant portion of the ruleset scheme is being communicated."
						},
						"vtlVersion":{
							"type":"string"
						},
						"rulesets":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/RulesetType",
								"description":"Ruleset details a ruleset within a ruleset scheme."
							}
						},
						"vtlMappingScheme":{
							"$ref":"#/definitions/VtlMappingSchemeReferenceType",
							"description":"References a VTL mapping scheme which defines aliases for given SDMX artefacts that are used in the rulesets. Rulesets defined on value domains reference Codelists or Concept Schemes (the latter in VTL are considered as the Value Domains of the variables corresponding to the SDMX Measure Dimensions). The rulesets defined on variables reference Concepts (for which a definite representation is assumed). Therefore, a ruleset should only refer to Codelists, Concept Schemes, and Concepts."
						}
					}
				}
			]
		},
		"RulesetType":{
			"description":"RulesetType defines the structure of a ruleset. A ruleset is a persistent set of rules which can be invoked by using appropriate VTL operators.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/NameableType"
				},
				{
					"properties":{
						"rulesetDefinition":{
							"type":"string",
							"description":"A VTL statement for the definition of a ruleset. This must conform to the syntax of the VTL definition language."
						},
						"rulesetType":{
							"type":"string",
							"description":"The VTL type of the ruleset. In VTL 2.0, this is datapoint or hierarchical."
						},
						"rulesetScope":{
							"type":"string",
							"description":"This model artefact on which the ruleset is defined. In VTL 2.0, this is value domain or variable."
						}
					},
					"required":[
						"id",
						"rulesetDefinition",
						"rulesetType",
						"rulesetScope"
					]
				}
			]
		},
		"TransformationSchemeType":{
			"description":"TransformationSchemeType describes the structure of a transformation scheme. A transformation scheme contains a set of transformations to be executed together (in the same run). It can contain any number of transformations that produce any number of results. Unless the artefact is returned as a stub, it must contain the 'vtlVersion' property.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableType"
				},
				{
					"properties":{
						"isPartial":{
							"type":"boolean",
							"description":"isPartial, if true, indicates that only the relevant portion of the transformation scheme is being communicated."
						},
						"vtlVersion":{
							"type":"string"
						},
						"transformations":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/TransformationType",
								"description":"Transformation describes the details of a single transformation within a transformation scheme."
							}
						},
						"vtlMappingScheme":{
							"description":"References a VTL mapping scheme (through a URN), which defines aliases for given SDMX artefacts that are used in the transformations as well as the mapping methods used when converting between SDMX and VTL data structures. All aliases must be defined in the referenced scheme. This also must be used if the basic mapping methods are not used.",
							"$ref":"#/definitions/VtlMappingSchemeReferenceType"
						},
						"namePersonalisationScheme":{
							"description":"References a name personalisation scheme (through a URN), which defines the overriding of some standard VTL names (to be assigned to some measures and/or attributes of the data structure) with some corresponding personalised names. This must be used if transformations within a transformation scheme personalise standard names. All personalisations must be defined in the referenced scheme.",
							"$ref":"#/definitions/NamePersonalisationSchemeReferenceType"
						},
						"customTypeScheme":{
							"description":"References a custom type scheme (through a URN), which defines custom conversions of VTL scalar types to SDMX data types. This must be used if custom type conversions are used in the transformations defined in a transformation scheme. All custom conversions must be defined in the referenced scheme.",
							"$ref":"#/definitions/CustomTypeSchemeReferenceType"
						},
						"rulesetSchemes":{
							"type":"array",
							"uniqueItems":true,
							"minItems":1,
							"items":{
								"$ref":"#/definitions/RulesetSchemeReferenceType",
								"description":"References a ruleset scheme (through a URN) that defines one or more previously defined rulesets which can be invoked by VTL operators. If a transformation defined in a transformation scheme refers to a ruleset, the scheme in which the ruleset is defined must be referenced here."
							}
						},
						"userDefinedOperatorSchemes":{
							"type":"array",
							"uniqueItems":true,
							"minItems":1,
							"items":{
								"$ref":"#/definitions/UserDefinedOperatorSchemeReferenceType",
								"description":"References a user defined operator scheme (through a URN) that defines one or more user defined operators used by the transformations defined in a transformation scheme. If a transformation in a transformation scheme refers to a user defined operator, the scheme in which the user defined operator is defined must be referenced here."
							}
						}
					}
				}
			]
		},
		"TransformationType":{
			"description":"TransformationType defines the structure of a transformation. A transformation is an assignment of a VTL expression to a specific result.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/NameableType"
				},
				{
					"properties":{
						"expression":{
							"type":"string",
							"description":"The right-hand side of the VTL statement. This is expression that is executed for this transformation. It include references to operands and other artefacts. The expression may contain references to SDMX artefacts using the reduced URN format; see Section 6 SDMX Standards ('SDMX Technical Notes'), 10.2.3 ('Abbreviation of the URN')"
						},
						"result":{
							"type":"string",
							"description":"The left-hand side of the VTL statement. This identifies the result artefact, which may be used in subsequent transformations. If the result is an SDMX artefact, the is expressed using the alias; see Section 6 SDMX Standards ('SDMX Technical Notes'), 10.2.3 ('Abbreviation of the URN')."
						},
						"isPersistent":{
							"type":"boolean",
							"description":"Indicates if the the result is permanently stored. A persistent result (value of true) can be used by transformation defined in other transformation schemes, but a non-persistent result (value of false) can only be used by transformations within the same transformation scheme."
						}
					},
					"required":[
						"id",
						"expression",
						"result",
						"isPersistent"
					]
				}
			]
		},
		"UserDefinedOperatorSchemeType":{
			"description":"UserDefinedOperatorSchemeType defines a collection of user defined operators that are used in transformations. Unless the artefact is returned as a stub, it must contain the 'vtlVersion' property.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableType"
				},
				{
					"properties":{
						"isPartial":{
							"type":"boolean",
							"description":"isPartial, if true, indicates that only the relevant portion of the user defined operator scheme is being communicated."
						},
						"vtlVersion":{
							"type":"string"
						},
						"userDefinedOperators":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/UserDefinedOperatorType",
								"description":"UserDefinedOperator details a user defined operators within a user defined operator scheme."
							}
						},
						"vtlMappingScheme":{
							"$ref":"#/definitions/VtlMappingSchemeReferenceType",
							"description":"References a VTL mapping scheme which defines aliases for given SDMX artefacts that are used in the user defined operators. Although the VTL user defined operators are conceived to be defined on generic operands, so that the specific artefacts to be manipulated are passed as parameters at the invocation, it is also possible that they reference specific SDMX artefacts like Dataflows, Codelists and ConceptSchemes. In this case, the mapping schemes referenced here define the mappings to those artefacts."
						},
						"rulesetSchemes":{
							"type":"array",
							"uniqueItems":true,
							"minItems":1,
							"items":{
								"$ref":"#/definitions/RulesetSchemeReferenceType",
								"description":"References a ruleset scheme defining rulesets utilized in the user defined operators."
							}
						}
					}
				}
			]
		},
		"UserDefinedOperatorType":{
			"description":"UserDefinedOperatorType defines the structure of a user defined operator. A user defined operator is a custom VTL operator (not existing in the standard library) that extends the VTL standard library for specific purposes. In addition to its identification and name, and definition of the operator must be provided.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/NameableType"
				},
				{
					"properties":{
						"operatorDefinition":{
							"type":"string",
							"description":"A VTL statement for the definition of a new operator: it specifies the operator name, its parameters and their data types, the VTL expression that defines its behaviour."
						}
					},
					"required":[
						"id",
						"operatorDefinition"
					]
				}
			]
		},
		"InputOutputType":{
			"description":"InputOutputType describes the structure of an input or output to a process step. It provides a reference to the object that is the input or output.",
			"type":"object",
			"properties":{
				"localID":{
					"$ref":"#/definitions/idType"
				},
				"annotations":{
					"$ref":"#/definitions/AnnotationsType"
				},
				"objectReference":{
					"$ref":"#/definitions/urn",
					"description":"ObjectReference is an abstract substitution head that references (through a urn) the object that is an input or output. It is substituted with a concrete reference to an explicit object type."
				}
			},
			"required":[
				"objectReference"
			]
		},
		"LevelType":{
			"description":"LevelType describes a level in a hierarchical codelist. Where level is defined as a group where codes can be characterised by homogeneous coding, and where the parent of each code in the group is at the same higher level of the hierarchy.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/NameableType"
				},
				{
					"properties":{
						"codingFormat":{
							"$ref":"#/definitions/CodingTextFormatType",
							"description":"CodingFormat specifies the text formatting of the codes in this level. This includes facets such as the expected characters and the length of the codes."
						},
						"level":{
							"$ref":"#/definitions/LevelType",
							"description":"Level describes the next level down in the hierarchy."
						}
					},
					"required":[
						"id"
					]
				}
			]
		},
		"MeasureRepresentationType":{
			"description":"MeasureRepresentationType defines the representation for a measure. A measure can be text (including XHTML and multi-lingual values), a simple value, or an enumerated value.",
			"type":"object",
			"oneOf":[
				{
					"properties":{
						"enumeration":{
							"$ref":"#/definitions/AnyCodelistReferenceType",
							"description":"Urn reference to an item scheme or value list."
						},
						"enumerationFormat":{
							"$ref":"#/definitions/CodedTextFormatType"
						},
						"maxOccurs":{
							"$ref":"#/definitions/OccurenceType",
							"default":1
						},
						"minOccurs":{
							"type":"integer",
							"minimum":0,
							"default":1
						}
					},
					"required":[
						"enumeration"
					]
				},
				{
					"properties":{
						"format":{
							"$ref":"#/definitions/BasicComponentTextFormatType"
						},
						"maxOccurs":{
							"$ref":"#/definitions/OccurenceType",
							"default":1
						},
						"minOccurs":{
							"type":"integer",
							"minimum":0,
							"default":1
						}
					},
					"required":[
						"format"
					]
				}
			]
		},
		"MeasureListType":{
			"description":"MeasureListType describes the structure of the measure descriptor for a data structure definition.",
			"type":"object",
			"allOf":[
				{
					"properties":{
						"id":{
							"const":"MeasureDescriptor"
						},
						"links":{
							"$ref":"#/definitions/links",
							"description":"Links field is an array of link objects. Also used to specify the URI or the URN to itself. If appropriate, a collection of links to additional external resources."
						}
					}
				},
				{
					"$ref":"#/definitions/AnnotableType"
				},
				{
					"properties":{
						"measures":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/MeasureType",
								"description":"Measure defines the structure of a measure, which is the concept that is the value of the phenomenon to be measured in a data set."
							}
						}
					}
				}
			]
		},
		"MetadataAttributeRepresentationType":{
			"description":"MetadataAttributeRepresentationType defines the possible local representations of a metadata attribute.",
			"type":"object",
			"oneOf":[
				{
					"properties":{
						"enumeration":{
							"$ref":"#/definitions/CodelistReferenceType",
							"description":"Urn reference to a codelist"
						},
						"enumerationFormat":{
							"$ref":"#/definitions/CodedTextFormatType"
						}
					},
					"required":[
						"enumeration"
					]
				},
				{
					"properties":{
						"format":{
							"$ref":"#/definitions/BasicComponentTextFormatType"
						}
					},
					"required":[
						"format"
					]
				}
			]
		},
		"MetadataAttributeType":{
			"description":"MetadataAttributeType describes the structure of a metadata attribute. The metadata attribute takes its semantic, and in some cases it representation, from its concept identity. A metadata attribute may be coded (via the local representation), uncoded (via the text format), or take no value. In addition to this value, the metadata attribute may also specify subordinate metadata attributes. If a metadata attribute only serves the purpose of containing subordinate metadata attributes, then the isPresentational attribute should be used. Otherwise, it is assumed to also take a value. If the metadata attribute does take a value, and a representation is not defined, it will be inherited from the concept it takes its semantic from. The optional id on the metadata attribute uniquely identifies it within the metadata structured definition. If this id is not supplied, its value is assumed to be that of the concept referenced from the concept identity. Note that a metadata attribute (as identified by the id attribute) definition  must be unique across the entire metadata structure definition (including target identifier, identifier component, and report structure ids). A metadata attribute may be used in multiple report structures and at different levels, but the content (value and/or child metadata attributes and their cardinality) of the metadata attribute cannot change.",
			"type":"object",
			"required":[
				"conceptIdentity"
			],
			"allOf":[
				{
					"$ref":"#/definitions/IdentifiableTypeWithNCNameID"
				},
				{
					"properties":{
						"isPresentational":{
							"type":"boolean",
							"description":"The isPresentational attribute indicates whether the metadata attribute should allow for a value. A value of true, meaning the metadata attribute is presentational means that the attribute only contains child metadata attributes, and does not contain a value. If this attribute is not set to true, and a representation (coded or uncoded) is not defined, then the representation of the metadata attribute will be inherited from the concept from which it takes its identity."
						},
						"maxOccurs":{
							"$ref":"#/definitions/OccurenceType",
							"default":1,
							"description":"The maxOccurs attribute indicates the maximum number of times this metadata attribute can occur within its parent object."
						},
						"minOccurs":{
							"type":"integer",
							"minimum":0,
							"default":1,
							"description":"The minOccurs attribute indicates the minimum number of times this metadata attribute must occur within its parent object."
						},
						"conceptIdentity":{
							"$ref":"#/definitions/ConceptReferenceType",
							"description":"Urn reference to a concept where the identification of the concept scheme which defines it is contained in another context."
						},
						"localRepresentation":{
							"$ref":"#/definitions/MetadataAttributeRepresentationType"
						},
						"metadataAttributes":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/MetadataAttributeType"
							}
						}
					}
				}
			]
		},
		"MetadataStructureComponentsType":{
			"description":"MetadataStructureComponentsType describes the structure of one set of components, the metadata attribute list, that make up the metadata structure definition. At a minimum, at least one metadata attribute must be defined.",
			"type":"object",
			"properties":{
				"metadataAttributeList":{
					"$ref":"#/definitions/MetadataAttributeListType",
					"description":"MetadataAttributeList defines the set of metadata attributes that can be defined as a hierarchy, for reporting reference metadata about a target object. The identification of metadata attributes must be unique at any given level of the metadata structure. Although there are XML schema constraints to help enforce this, these only apply to explicitly assigned identifiers. Identifiers inherited from a concept from which a metadata attribute takes its identity cannot be validated against this constraint. Therefore, systems processing metadata structure definitions will have to perform this check outside of the XML validation."
				}
			}
		},
		"MetadataStructureType":{
			"description":"MetadataStructureType is used to describe a metadata structure definition, which is defined as a collection of metadata concepts, their structure and usage when used to collect or disseminate reference metadata.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableType"
				},
				{
					"properties":{
						"metadataStructureComponents":{
							"$ref":"#/definitions/MetadataStructureComponentsType",
							"description":"MetadataStructureComponents defines the grouping of the sets of the components that make up the metadata structure definition."
						}
					}
				}
			]
		},
		"MetadataflowType":{
			"description":"MetadataflowType describes the structure of a metadata flow. A dataflow is defined as the structure of reference metadata that will be provided for different reference periods. If this type is not referenced externally, then a reference to a metadata structure definition must be provided. Unless the artefact is returned as a stub, it must contain the 'targets' property.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableType"
				},
				{
					"properties":{
						"structure":{
							"$ref":"#/definitions/MetadataStructureReferenceType",
							"description":"Structure provides a urn reference to the metadata structure definition describing the structure of all reference metadata for this flow."
						},
						"targets":{
							"type":"array",
							"uniqueItems":true,
							"minItems":1,
							"items":{
								"$ref":"#/definitions/WildcardObjectReferenceType",
								"description":"References identifiable structures to which the reference metadata described by the referenced metadata structure should be restricted to. These references may include wildcards for parts of the reference."
							}
						}
					}
				}
			]
		},
		"OrganisationSchemeMapType":{
			"description":"OrganisationSchemeMapType defines the structure of a map which identifies relationships between organisations in different organisation schemes. Unless the artefact is returned as a stub, it must contain the 'source' and 'target' properties.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableType"
				},
				{
					"properties":{
						"itemMaps":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/SingleValueMappingType"
							}
						},
						"source":{
							"$ref":"#/definitions/OrganisationSchemeReferenceType",
							"description":"Urn reference to a concept scheme object."
						},
						"target":{
							"$ref":"#/definitions/OrganisationSchemeReferenceType",
							"description":"Urn reference to a concept scheme object."
						}
					}
				}
			]
		},
		"OrganisationUnitSchemeType":{
			"description":"OrganisationUnitSchemeType defines a type of organisation scheme which simply defines organisations and there parent child relationships. Organisations in this scheme are assigned no particular role, and may in fact exist within the other type of organisation schemes as well.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableWithoutVersionType"
				},
				{
					"properties":{
						"id":{
							"$ref":"#/definitions/idType"
						},
						"isPartial":{
							"type":"boolean",
							"description":"isPartial, if true, indicates that only the relevant portion of the organisation unit scheme is being communicated."
						},
						"organisationUnits":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/OrganisationUnitType",
								"description":"OrganisationUnit describes a generic organisation, which serves not predefined role in SDMX."
							}
						}
					}
				}
			]
		},
		"OrganisationUnitType":{
			"description":"OrganisationUnitType defines the structure of an organisation unit description. In addition to general identification and contact information, an organisation unit can specify a relationship with another organisation unit from the same scheme which is its parent organisation.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/NameableType"
				},
				{
					"properties":{
						"contacts":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/contactType"
							}
						},
						"parent":{
							"$ref":"#/definitions/idType",
							"description":"ID of an organisation unit, where the reference to the organisation unit scheme which defines it is provided in another context."
						}
					},
					"required":[
						"id"
					]
				}
			]
		},
		"MeasureType":{
			"description":"MeasureType defines the structure of a measure descriptor. In addition to the identifying concept and representation, a mandatory usage and max occurs can be defined.",
			"type":"object",
			"required":[
				"conceptIdentity"
			],
			"allOf":[
				{
					"$ref":"#/definitions/IdentifiableTypeWithNCNameID"
				},
				{
					"properties":{
						"usage":{
							"$ref":"#/definitions/UsageType",
							"default":"optional",
							"description":"The usage attribute indicates whether a measure value must be available for any corresponding existing observation."
						},
						"conceptIdentity":{
							"$ref":"#/definitions/ConceptReferenceType",
							"description":"Urn reference to a concept where the identification of the concept scheme which defines it is contained in another context."
						},
						"conceptRoles":{
							"description":"ConceptRole references concepts which define roles which this measure serves. If the concept from which the attribute takes its identity also defines a role the concept serves, then the isConceptRole indicator can be set to true on the concept identity rather than repeating the reference here.",
							"type":"array",
							"minItems":1,
							"uniqueItems":true,
							"items":{
								"$ref":"#/definitions/ConceptReferenceType",
								"description":"Urn reference to a concept where the identification of the concept scheme which defines it is contained in another context."
							}
						},
						"localRepresentation":{
							"$ref":"#/definitions/MeasureRepresentationType"
						}
					}
				}
			]
		},
		"ProcessStepType":{
			"description":"ProcessStepType describes the structure of a process step. A nested process step is automatically sub-ordinate, and followed as the next step. If the following step is conditional, it should be referenced in a transition.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/NameableType"
				},
				{
					"properties":{
						"computation":{
							"$ref":"#/definitions/ComputationType",
							"description":"Computation describes the computations involved in the process, in any form desired by the user (these are informational rather than machine-actionable), and so may be supplied in multiple, parallel-language versions."
						},
						"inputs":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/InputOutputType",
								"description":"Input references an object which is an input to the process step."
							}
						},
						"outputs":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/InputOutputType",
								"description":"Output references an object which is an output form the process step."
							}
						},
						"processSteps":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/ProcessStepType",
								"description":"ProcessStep defines a process step, which is a specific operation, performed on data in order to validate or to derive new information according to a given set of rules."
							}
						},
						"transitions":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/TransitionType",
								"description":"Transition describes the next process steps. Each transition in a process step should be evaluated, allowing for multiple process step branches from a single process step."
							}
						}
					},
					"required":[
						"id"
					]
				}
			]
		},
		"ProcessType":{
			"description":"ProcessType describes the structure of a process, which is a scheme which defines or documents the operations performed on data in order to validate data or to derive new information according to a given set of rules. Processes occur in order, and will continue in order unless a transition dictates another step should occur.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableType"
				},
				{
					"properties":{
						"processSteps":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/ProcessStepType",
								"description":"ProcessStep defines a process step, which is a specific operation, performed on data in order to validate or to derive new information according to a given set of rules."
							}
						}
					}
				}
			]
		},
		"ProvisionAgreementType":{
			"description":"ProvisionAgreementType describes the structure of a provision agreement. A provision agreement defines an agreement for a data provider to report data against a dataflow. Attributes which describe how the registry must behave when data is registered against this provision agreement are supplied. Unless the artefact is returned as a stub, it must contain the 'dataflow' and 'dataProvider' properties.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableType"
				},
				{
					"properties":{
						"dataflow":{
							"$ref":"#/definitions/DataflowReferenceType",
							"description":">Dataflow provides a reference to a pre-existing dataflow in the registry via a URN"
						},
						"dataProvider":{
							"$ref":"#/definitions/DataProviderReferenceType",
							"description":"DataProvider provides a reference to a pre-existing data provider in the registry via a URN."
						}
					}
				}
			]
		},
		"MetadataProvisionAgreementType":{
			"description":"MetadataProvisionAgreementType describes the structure of a metadata provision agreement. A metadata provision agreement defines an agreement for a metadata provider to report reference metadata against a metadataflow. Attributes which describe how the registry must behave when metadata is registered against this metadata provision agreement are supplied. Unless the artefact is returned as a stub, it must contain the 'metadataflow' and 'dataProvider' properties.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableType"
				},
				{
					"properties":{
						"metadataflow":{
							"$ref":"#/definitions/MetadataflowReferenceType",
							"description":">Metadataflow provides a reference to a pre-existing metadataflow in the registry via a URN."
						},
						"metadataProvider":{
							"$ref":"#/definitions/MetadataProviderReferenceType",
							"description":"MetadataProvider provides a reference to a pre-existing metadata provider in the registry via a URN."
						},
						"targets":{
							"type":"array",
							"uniqueItems":true,
							"minItems":1,
							"items":{
								"$ref":"#/definitions/WildcardObjectReferenceType"
							},
							"description":"References identifiable structures to which the reference metadata described by the metadata structure used by the metadaflow should be restricted to. These references may include wildcards for parts of the reference."
						}
					}
				}
			]
		},
		"ReleaseCalendarType":{
			"description":"ReleaseCalendarType describes information about the timing of releases of the constrained data. All of these values use the standard \"P7D\" - style format.",
			"type":"object",
			"properties":{
				"offset":{
					"description":"Offset is the interval between January first and the first release of data within the year.",
					"type":"string"
				},
				"periodicity":{
					"description":"Periodicity is the period between releases of the data set.",
					"type":"string"
				},
				"tolerance":{
					"description":"Tolerance is the period after which the release of data may be deemed late.",
					"type":"string"
				}
			},
			"required":[
				"offset",
				"periodicity",
				"tolerance"
			]
		},
		"ReportingCategoryType":{
			"description":"ReportingCategoryType describes the structure of a reporting category, which groups structure usages into useful sub-packages. Sub ordinate reporting categories can be nested within the category definition.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/NameableType"
				},
				{
					"properties":{
						"reportingCategories":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/ReportingCategoryType",
								"description":"ReportingCategory defines a reporting category, which is used to group structure usages into useful sub-packages."
							}
						},
						"structuralMetadata":{
							"type":"array",
							"minItems":1,
							"uniqueItems":true,
							"items":{
								"$ref":"#/definitions/StructureReferenceType",
								"description":"StructuralMetadata provides urn references for data structure definition and metadata structure definition references which are grouped in the reporting category. It is assumed that all structural metadata objects referenced from a category will be of the same type."
							}
						},
						"provisioningMetadata":{
							"type":"array",
							"minItems":1,
							"uniqueItems":true,
							"items":{
								"$ref":"#/definitions/StructureUsageReferenceType",
								"description":"ProvisioningMetadata provides urn references for dataflow and metadataflow references which are grouped in the reporting category. It is assumed that all provisioning metadata objects referenced from a category will be of the same type."
							}
						}
					},
					"required":[
						"id"
					],
					"anyOf":[
						{
							
						},
						{
							"required":[
								"structuralMetadata"
							]
						},
						{
							"required":[
								"provisioningMetadata"
							]
						}
					],
					"not":{
						"required":[
							"structuralMetadata",
							"provisioningMetadata"
						]
					}
				}
			]
		},
		"ReportingTaxonomyMapType":{
			"description":"ReportingTaxonomyMapType defines the structure of a map which identifies relationships between reporting categories in different reporting taxonomies. Unless the artefact is returned as a stub, it must contain the 'source' and 'target' properties.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableType"
				},
				{
					"properties":{
						"itemMaps":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/SingleValueMappingType"
							}
						},
						"source":{
							"$ref":"#/definitions/ReportingTaxonomyReferenceType",
							"description":"Urn reference to a concept scheme object."
						},
						"target":{
							"$ref":"#/definitions/ReportingTaxonomyReferenceType",
							"description":"Urn reference to a concept scheme object."
						}
					}
				}
			]
		},
		"ReportingTaxonomyType":{
			"description":"ReportingTaxonomyType describes the structure of a reporting taxonomy, which is a scheme which defines the composition structure of a data report where each component can be described by an independent structure or structure usage description.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableType"
				},
				{
					"properties":{
						"isPartial":{
							"type":"boolean",
							"description":"isPartial, if true, indicates that only the relevant sub set of the reporting categories is being communicated."
						},
						"reportingCategories":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/ReportingCategoryType",
								"description":"ReportingCategory defines a reporting category, which is used to group structure usages into useful sub-packages."
							}
						}
					}
				}
			]
		},
		"ReportingYearStartOrEndDayRepresentationType":{
			"description":"ReportingYearStartOrEndDayRepresentationType defines the representation for the reporting year start/end day attribute. Enumerated values are not allowed and the text format is fixed to be a day and month in the ISO 8601 format of '--MM-DD'.",
			"type":"object",
			"properties":{
				"format":{
					"$ref":"#/definitions/ReportingYearStartOrEndDayTextFormatType"
				},
				"maxOccurs":{
					"const":1
				},
				"minOccurs":{
					"type":"integer",
					"minimum":0,
					"maximum":1,
					"default":1
				}
			},
			"required":[
				"format",
				"maxOccurs"
			]
		},
		"ReportingYearStartOrEndDayTextFormatType":{
			"description":"ReportingYearStartOrEndDayTextFormatType is a restricted version of the NonFacetedTextFormatType that fixes the value of the text type to be MonthDay. This type exists solely for the purpose of fixing the representation of the reporting year start/end day attribute.",
			"type":"object",
			"properties":{
				"dataType":{
					"const":"MonthDay"
				}
			},
			"required":[
				"dataType"
			],
			"additionalProperties":false
		},
		"ReportingYearStartOrEndDayType":{
			"description":"ReportingYearStartOrEndDayType defines the structure of the reporting year start or end day attribute. The reporting year start/end day attribute takes its semantic from its concept identity (usually the REPORTING_YEAR_START_DAY or REPORTING_YEAR_END_DAY concepts), yet always has a fixed identifier (REPORTING_YEAR_START_DAY, REPORTING_YEAR_END_DAY). The reporting year start/end day attribute always has a fixed text format, which specifies that the format of its value is always a day and month in the ISO 8601 format of '--MM-DD'. As with any other attribute, an attribute relationship must be specified. This relationship should be carefully selected as it will determine what type of data the data structure definition will allow. For example, if an attribute relationship of `dataflow` is specified, this will mean the data sets for this dataflow can only contain data with standard reporting periods where the all reporting periods have the same start/end day. In this case, data reported as standard reporting periods from two entities with different fiscal year start/end days could not be contained in the same data set.",
			"type":"object",
			"required":[
				"id",
				"attributeRelationship",
				"conceptIdentity",
				"localRepresentation"
			],
			"allOf":[
				{
					"$ref":"#/definitions/AnnotableType"
				},
				{
					"properties":{
						"id":{
							"type":"string",
							"enum":[
								"REPORTING_YEAR_START_DAY",
								"REPORTING_YEAR_END_DAY"
							]
						},
						"links":{
							"$ref":"#/definitions/links",
							"description":"Links field is an array of link objects. Also used to specify the URI or the URN to itself. If appropriate, a collection of links to additional external resources."
						},
						"usage":{
							"$ref":"#/definitions/UsageType",
							"default":"mandatory",
							"description":"The usage attribute indicates whether a ReportingYearStartDay/ReportingYearEndDay attribute value must be available for any corresponding existing observation."
						},
						"attributeRelationship":{
							"$ref":"#/definitions/AttributeRelationshipType",
							"description":"AttributeRelationship describes how the value of this attribute varies with the values of other components. These relationships will be used to determine the attachment level of the attribute in the various data formats."
						},
						"measureRelationship":{
							"type":"array",
							"uniqueItems":true,
							"minItems":1,
							"items":{
								"$ref":"#/definitions/NCNameIDType"
							},
							"description":"The measureRelationship array identifies the measures that the attribute applies to. If this is not used, the attribute is assumed to apply to all measures. If used, it contains one or more identifiers of (a) local measure(s)."
						},
						"conceptIdentity":{
							"$ref":"#/definitions/ConceptReferenceType",
							"description":"Urn reference to a concept where the identification of the concept scheme which defines it is contained in another context."
						},
						"conceptRoles":{
							"type":"array",
							"minItems":1,
							"uniqueItems":true,
							"items":{
								"$ref":"#/definitions/ConceptReferenceType",
								"description":"ConceptRole references concepts which define roles which this attribute serves. If the concept from which the attribute takes its identity also defines a role the concept serves, then the isConceptRole indicator can be set to true on the concept identity rather than repeating the reference here."
							}
						},
						"localRepresentation":{
							"$ref":"#/definitions/ReportingYearStartOrEndDayRepresentationType"
						}
					}
				}
			]
		},
		"RepresentationMapType":{
			"description":"RepresentationMapType describes ...  Unless the artefact is returned as a stub, it must contain the 'source' and 'target' properties.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableType"
				},
				{
					"properties":{
						"source":{
							"type":"array",
							"minItems":1,
							"items":{
								"type":"object",
								"properties":{
									"codelist":{
										"$ref":"#/definitions/AnyCodelistReferenceType"
									},
									"dataType":{
										"$ref":"#/definitions/DataType"
									}
								},
								"oneOf":[
									{
										"required":[
											"codelist"
										]
									},
									{
										"required":[
											"dataType"
										]
									}
								]
							}
						},
						"target":{
							"type":"array",
							"minItems":1,
							"items":{
								"type":"object",
								"properties":{
									"codelist":{
										"$ref":"#/definitions/AnyCodelistReferenceType"
									},
									"dataType":{
										"$ref":"#/definitions/DataType"
									}
								},
								"oneOf":[
									{
										"required":[
											"codelist"
										]
									},
									{
										"required":[
											"dataType"
										]
									}
								]
							}
						},
						"representationMappings":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/ValueMappingType"
							}
						}
					}
				}
			]
		},
		"SimpleCodeDataType":{
			"description":"SimpleCodeDataType restricts SimpleDataType to specify the allowable data types for a simple code. The possible values are simply Alpha, AlphaNumeric, or Numeric.",
			"type":"string",
			"enum":[
				"Alpha",
				"AlphaNumeric",
				"Numeric"
			]
		},
		"SimpleComponentTextFormatType":{
			"description":"SimpleComponentTextFormatType is a restricted version of the BasicComponentTextFormatType that does not allow for multi-lingual values.",
			"type":"object",
			"properties":{
				"dataType":{
					"$ref":"#/definitions/SimpleDataType"
				},
				"isSequence":{
					"type":"boolean"
				},
				"interval":{
					"type":"integer"
				},
				"startValue":{
					"type":"number"
				},
				"endValue":{
					"type":"number"
				},
				"timeInterval":{
					"$ref":"#/definitions/duration"
				},
				"startTime":{
					"$ref":"#/definitions/StandardTimePeriodType"
				},
				"endTime":{
					"$ref":"#/definitions/StandardTimePeriodType"
				},
				"minLength":{
					"type":"integer",
					"minimum":1
				},
				"maxLength":{
					"type":"integer",
					"minimum":1
				},
				"minValue":{
					"type":"number"
				},
				"maxValue":{
					"type":"number"
				},
				"decimals":{
					"type":"integer",
					"minimum":1
				},
				"pattern":{
					"type":"string"
				},
				"sentinelValues":{
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/sentinelValueType",
						"description":"SentinelValue defines a value that has a special meaning within the text format representation of a component."
					}
				}
			}
		},
		"AttributeRepresentationType":{
			"description":"AttributeRepresentationType defines the representation for a data attribute. A data attribute can be text (including XHTML and multi-lingual values), a simple value, or an enumerated value",
			"type":"object",
			"oneOf":[
				{
					"properties":{
						"enumeration":{
							"$ref":"#/definitions/AnyCodelistReferenceType",
							"description":"Reference to an item scheme or a value list. It consists of a URN."
						},
						"enumerationFormat":{
							"$ref":"#/definitions/CodedTextFormatType"
						},
						"maxOccurs":{
							"$ref":"#/definitions/OccurenceType",
							"default":1
						},
						"minOccurs":{
							"type":"integer",
							"minimum":0,
							"default":1
						}
					},
					"required":[
						"enumeration"
					]
				},
				{
					"properties":{
						"format":{
							"$ref":"#/definitions/BasicComponentTextFormatType"
						},
						"maxOccurs":{
							"$ref":"#/definitions/OccurenceType",
							"default":1
						},
						"minOccurs":{
							"type":"integer",
							"minimum":0,
							"default":1
						}
					},
					"required":[
						"format"
					]
				}
			]
		},
		"SimpleDataStructureRepresentationType":{
			"description":"SimpleDataStructureRepresentationType defines the representation for any non-time dimension data structure definition component.",
			"type":"object",
			"oneOf":[
				{
					"properties":{
						"enumeration":{
							"$ref":"#/definitions/CodelistReferenceType",
							"description":"Urn reference to a codelist"
						},
						"enumerationFormat":{
							"$ref":"#/definitions/CodedTextFormatType"
						}
					},
					"required":[
						"enumeration"
					]
				},
				{
					"properties":{
						"format":{
							"$ref":"#/definitions/SimpleComponentTextFormatType"
						}
					},
					"required":[
						"format"
					]
				}
			]
		},
		"StructureMapType":{
			"description":"StructureMapType defines the structure for mapping components of one structure to components of another structure. A structure may be referenced directly meaning the map applies wherever the structure is used, or it may be a reference via a structure usage meaning the map only applies within the context of that usage. Using the related structures, one can make extrapolations between maps. For example, if key families, A, B, and C, are all grouped in a related structures container, then a map from data structure A to C and a map from data structure B to C could be used to infer a relation between data structure A to C. Unless the artefact is returned as a stub, it must contain the 'source', 'target' and 'componentMaps' properties.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/MaintainableType"
				},
				{
					"properties":{
						"source":{
							"$ref":"#/definitions/StructureOrUsageReferenceType",
							"description":"Source provides a reference to a structure (data or metadata) or a structure usage (dataflow or metadataflow) from which components defined by the actual structure are to mapped."
						},
						"target":{
							"$ref":"#/definitions/StructureOrUsageReferenceType",
							"description":"Target provides a reference to a structure (data or metadata) or a structure usage (dataflow or metadataflow) to which components from the source are to mapped."
						},
						"epochMaps":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/EpochMapType",
								"description":"Provides the ability to map source to target date formats. The source date is described as the number of epochs since a point in time, where the duration of each epoch is defined, e.g. number of milliseconds since 1970."
							}
						},
						"datePatternMaps":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/DatePatternMapType",
								"description":"Provides the ability to map source to target date formats. The source date is described as a pattern (for example MM-YYYY)."
							}
						},
						"frequencyFormatMappings":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/FrequencyFormatMappingType",
								"description":"Provides..."
							}
						},
						"componentMaps":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/ComponentMapType",
								"description":"ComponentMap defines the relationship between the components of the source and target structures, including information on how the value from the source component relates to values in the target component."
							}
						},
						"fixedValueMaps":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/FixedValueMapType",
								"description":"FixedValueMap defines a fixed value for a source or target component in the mapping."
							}
						}
					}
				}
			]
		},
		"EpochMapType":{
			"description":"...",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/DateMapType"
				},
				{
					"required":[
						"basePeriod",
						"epochPeriod"
					],
					"properties":{
						"basePeriod":{
							"type":"string"
						},
						"epochPeriod":{
							"description":"EpochPeriod defines an enumeration of epoch period types.",
							"type":"string",
							"enum":[
								"nanosecond",
								"millisecond",
								"microsecond",
								"second",
								"day"
							]
						}
					}
				}
			]
		},
		"DatePatternMapType":{
			"description":"...",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/DateMapType"
				},
				{
					"required":[
						"sourcePattern",
						"locale"
					],
					"properties":{
						"sourcePattern":{
							"description":"Describes the source date using conventions for describing years, months, days, etc.",
							"type":"string"
						},
						"locale":{
							"description":"The locale on which the input will be parsed according to the pattern.",
							"type":"string"
						}
					}
				}
			]
		},
		"DateMapType":{
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/IdentifiableType"
				},
				{
					"required":[
						"mappedComponents"
					],
					"properties":{
						"mappedComponents":{
							"type":"array",
							"minItems":1,
							"items":{
								"type":"object",
								"required":[
									"source",
									"target"
								],
								"properties":{
									"source":{
										"$ref":"#/definitions/NestedIDType",
										"description":"(Nested) ID of a local source component."
									},
									"target":{
										"$ref":"#/definitions/NestedIDType",
										"description":"(Nested) ID of a local target component."
									}
								}
							}
						},
						"resolvePeriod":{
							"type":"string",
							"enum":[
								"startOfPeriod",
								"endOfPeriod",
								"midPeriod"
							],
							"description":"Indicates the point in time to resolve to when mapping from low fequency periods to higher frequency periods."
						}
					}
				},
				{
					"oneOf":[
						{
							"required":[
								"frequencyDimension"
							],
							"properties":{
								"frequencyDimension":{
									"$ref":"#/definitions/idType"
								},
								"mappedFrequencies":{
									"type":"array",
									"minItems":1,
									"items":{
										"$ref":"#/definitions/idType",
										"description":"ID of a local frequency format mapping object."
									}
								}
							}
						},
						{
							"required":[
								"targetFrequencyID"
							],
							"properties":{
								"targetFrequencyID":{
									"$ref":"#/definitions/idType"
								}
							}
						}
					]
				}
			]
		},
		"FrequencyFormatMappingType":{
			"description":"...",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/IdentifiableType"
				},
				{
					"required":[
						"frequencyId",
						"datePattern"
					],
					"properties":{
						"frequencyId":{
							"$ref":"#/definitions/idType"
						},
						"datePattern":{
							"type":"string"
						}
					}
				}
			]
		},
		"ComponentMapType":{
			"description":"ComponentMapType defines the structure for relating a component in a source structure to a component in a target structure.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/AnnotableType"
				},
				{
					"required":[
						"source",
						"target"
					],
					"properties":{
						"source":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/NestedIDType",
								"description":"(Nested) ID of a local source component."
							}
						},
						"target":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/NestedIDType",
								"description":"(Nested) ID of a local target component."
							}
						},
						"representationMap":{
							"$ref":"#/definitions/RepresentationMapReferenceType",
							"description":"URN for referencing a representation map object."
						}
					}
				}
			]
		},
		"FixedValueMapType":{
			"description":"FixedValueMapType defines the structure for providing a fixed value for a source or target component.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/AnnotableType"
				},
				{
					"oneOf":[
						{
							"required":[
								"source"
							],
							"properties":{
								"source":{
									"$ref":"#/definitions/NestedIDType"
								}
							}
						},
						{
							"required":[
								"target"
							],
							"properties":{
								"target":{
									"$ref":"#/definitions/NestedIDType"
								}
							}
						}
					]
				},
				{
					"properties":{
						"values":{
							"type":"array",
							"minItems":1,
							"items":{
								"type":"string",
								"description":"The fixed value for the component."
							}
						}
					}
				}
			]
		},
		"TimeDimensionRepresentationType":{
			"description":"TimeDimensionRepresentationType defines the representation for the time dimension. Enumerated values are not allowed.",
			"type":"object",
			"properties":{
				"format":{
					"$ref":"#/definitions/TimeTextFormatType"
				}
			},
			"required":[
				"format"
			]
		},
		"TimeDimensionType":{
			"description":"TimeDimensionType describes the structure of a time dimension. The time dimension takes its semantic from its concept identity (usually the TIME_PERIOD concept), yet is always has a fixed identifier (TIME_PERIOD). The time dimension always has a fixed text format, which specifies that its format is always the in the value set of the observational time period (see common:ObservationalTimePeriodType). It is possible that the format may be a sub-set of the observational time period value set. For example, it is possible to state that the representation might always be a calendar year. See the enumerations of the dataType attribute in the LocalRepresentation/format for more details of the possible sub-sets. It is also possible to facet this representation with start and end dates. The purpose of such facts is to restrict the value of the time dimension to occur within the specified range. If the time dimension is expected to allow for the standard reporting periods (see common:ReportingTimePeriodType) to be used, then it is strongly recommended that the reporting year start day attribute also be included in the data structure definition. When the reporting year start day attribute is used, any standard reporting period values will be assumed to be based on the start day contained in this attribute. If the reporting year start day attribute is not included and standard reporting periods are used, these values will be assumed to be based on a reporting year which begins January 1.",
			"type":"object",
			"required":[
				"conceptIdentity",
				"localRepresentation"
			],
			"allOf":[
				{
					"properties":{
						"id":{
							"const":"TIME_PERIOD"
						},
						"links":{
							"$ref":"#/definitions/links",
							"description":"Links field is an array of link objects. Also used to specify the URI or the URN to itself. If appropriate, a collection of links to additional external resources."
						}
					}
				},
				{
					"$ref":"#/definitions/AnnotableType"
				},
				{
					"properties":{
						"conceptIdentity":{
							"$ref":"#/definitions/ConceptReferenceType",
							"description":"Urn reference to a concept where the identification of the concept scheme which defines it is contained in another context."
						},
						"localRepresentation":{
							"$ref":"#/definitions/TimeDimensionRepresentationType"
						}
					}
				}
			]
		},
		"TimeTextFormatType":{
			"description":"TimeTextFormat is a restricted version of the SimpleComponentTextFormatType that only allows time based format and specifies a default ObservationalTimePeriod representation and facets of a start and end time.",
			"type":"object",
			"properties":{
				"endTime":{
					"$ref":"#/definitions/StandardTimePeriodType"
				},
				"startTime":{
					"$ref":"#/definitions/StandardTimePeriodType"
				},
				"dataType":{
					"$ref":"#/definitions/TimeDataType"
				},
				"sentinelValues":{
					"type":"array",
					"minItems":1,
					"items":{
						"$ref":"#/definitions/sentinelValueType",
						"description":"SentinelValue defines a value that has a special meaning within the text format representation of a component."
					}
				}
			}
		},
		"sentinelValueType":{
			"description":"SentinelValueType defines the structure of a sentinel value. A sentinel is a value that has a special meaning within the text format representation of a component. The value is associated with a multi-lingual name and description.",
			"type":"object",
			"anyOf":[
				{
					"required":[
						"value",
						"name"
					]
				},
				{
					"required":[
						"value",
						"name",
						"names"
					]
				}
			],
			"properties":{
				"value":{
					"anyOf":[
						{
							"type":"string"
						},
						{
							"type":"number"
						},
						{
							"type":"integer"
						}
					],
					"description":"The sentinel value being described."
				},
				"name":{
					"description":"Human-readable (best-language-match) name (or meaning) of the sentinel value.",
					"$ref":"#/definitions/localisedBestMatchText"
				},
				"names":{
					"description":"Human-readable localised names (or meanings) of the sentinel value.",
					"$ref":"#/definitions/localisedText"
				},
				"description":{
					"$ref":"#/definitions/localisedBestMatchText"
				},
				"descriptions":{
					"$ref":"#/definitions/localisedText"
				}
			}
		},
		"TransitionType":{
			"description":"TransitionType describes the details of a transition, which is an expression in a textual or formalised way of the transformation of data between two specific operations performed on the data.",
			"type":"object",
			"required":[
				"condition",
				"targetStep"
			],
			"allOf":[
				{
					"$ref":"#/definitions/IdentifiableType"
				},
				{
					"properties":{
						"localID":{
							"$ref":"#/definitions/idType"
						},
						"condition":{
							"$ref":"#/definitions/localisedBestMatchText",
							"description":"Condition is a textual description of the conditions to be met in order for the target step to be proceeded to. It is informational only (not machine-actionable), provided in the best-match language."
						},
						"conditions":{
							"$ref":"#/definitions/localisedText",
							"description":"Condition is a textual description of the conditions to be met in order for the target step to be proceeded to. It is informational only (not machine-actionable), and may be supplied in multiple, parallel-language form."
						},
						"targetStep":{
							"$ref":"#/definitions/NestedIDType",
							"description":"TargetStep references (by nested ID) a local process or sub-process step within the process that should be transitioned to, should the conditions described be met."
						}
					}
				}
			]
		},
		"UsageType":{
			"description":"An enumeration of optional | mandatory to indicate the usage of an attribute or measure.",
			"type":"string",
			"enum":[
				"mandatory",
				"optional"
			]
		},
		"ValueMappingType":{
			"description":"ValueMappingType defines a mapping of multiple sources to multiple targets.",
			"type":"object",
			"allOf":[
				{
					"$ref":"#/definitions/AnnotableType"
				},
				{
					"properties":{
						"sourceValues":{
							"type":"array",
							"minItems":1,
							"items":{
								"$ref":"#/definitions/MappedValueType",
								"description":"There should be a source value for each source represention (e.g. codelist, data type). Source values can be pattern matched by using regular expression or substrings using start/end indexes."
							}
						},
						"targetValues":{
							"type":"array",
							"minItems":1,
							"items":{
								"type":"string",
								"description":"The target value(s) is always an absolute string. However, if source value is a regular expression, the target value can output the capture group from the source."
							}
						},
						"validFrom":{
							"type":"string",
							"format":"date-time"
						},
						"validTo":{
							"type":"string",
							"format":"date-time"
						}
					}
				}
			],
			"required":[
				"sourceValues"
			]
		},
		"MappedValueType":{
			"type":"object",
			"required":[
				"value"
			],
			"properties":{
				"value":{
					"type":"string"
				},
				"isRegEx":{
					"type":"boolean"
				},
				"startIndex":{
					"type":"integer"
				},
				"endIndex":{
					"type":"integer"
				}
			}
		},
		"uri":{
			"description":"Contains the URL to the schema allowing to validate the message. This also allows identifying the version of SDMX-JSON format used in this message. Providing the link to the SDMX-JSON schema is recommended.",
			"type":"string",
			"format":"uri"
		},
		"urn":{
			"description":"Universal Resource Name (URN) is constructed according to the generic structure 'urn:sdmx:org.SDMX-IM-package-name.class-name=agencyid:maintainedobject-id(maintainedobject-version).containerobject-id.object-id*'. For more information see: Unique identification of SDMX objects, in: SDMX STANDARDS: SECTION 5 SDMX REGISTRY SPECIFICATION",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.((base\\.((Agency)|(OrganisationUnitScheme)|(AgencyScheme)|(DataProviderScheme)|(MetadataProviderScheme)|(DataConsumerScheme)|(OrganisationUnit)|(DataProvider)|(MetadataProvider)|(DataConsumer)))|(codelist\\.((Codelist)|(Valuelist)|(Hierarchy)|(HierarchyAssociation)|(Code)|(HierarchicalCode)|(Level)))|(conceptscheme\\.((ConceptScheme)|(Concept)))|(datastructure\\.((DataStructure)|(AttributeDescriptor)|(DataAttribute)|(GroupDimensionDescriptor)|(DimensionDescriptor)|(Dimension)|(TimeDimension)|(MeasureDescriptor)|(Measure)|(Dataflow)))|(categoryscheme\\.((CategoryScheme)|(Category)|(Categorisation)|(ReportingTaxonomy)|(ReportingCategory)))|(registry\\.((ProvisionAgreement)|(MetadataProvisionAgreement)|(DataConstraint)|(MetadataConstraint)|(Subscription)))|(metadatastructure\\.((MetadataAttributeDescriptor)|(MetadataAttribute)|(MetadataStructure)|(Metadataflow)))|(process\\.((Process)|(ProcessStep)|(Transition)))|(structuremapping\\.((StructureMap)|(ComponentMap)|(EpochMap)|(DatePatternMap)|(ConceptSchemeMap)|(OrganisationSchemeMap)|(CategorySchemeMap)|(ReportingTaxonomyMap)|(RepresentationMap)|(FrequencyFormatMapping)))|(transformation\\.((TransformationScheme)|(Transformation)|(CustomTypeScheme)|(CustomType)|(NamePersonalisationScheme)|(NamePersonalisation)|(VtlMappingScheme)|(VtlCodelistMapping)|(VtlConceptMapping)|(VtlDataflowMapping)|(RulesetScheme)|(Ruleset)|(UserDefinedOperatorScheme)|(UserDefinedOperator))))=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)(\\.[A-Za-z0-9_@$-]+(\\.[A-Za-z0-9_@$-]+)*)?$"
		},
		"WildcardObjectReferenceType":{
			"description":"WildcardObjectReferenceType is a generic URN reference which allows for any object to be referenced with the ability to wildcard certain parts of the identifier. The type of object actually referenced can be determined from the URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.((base\\.((Any)|(Agency)|(OrganisationUnitScheme)|(AgencyScheme)|(DataProviderScheme)|(MetadataProviderScheme)|(DataConsumerScheme)|(OrganisationUnit)|(DataProvider)|(MetadataProvider)|(DataConsumer)))|(codelist\\.((Any)|(Codelist)|(Valuelist)|(Hierarchy)|(HierarchyAssociation)|(Code)|(HierarchicalCode)|(Level)))|(conceptscheme\\.((Any)|(ConceptScheme)|(Concept)))|(datastructure\\.((Any)|(DataStructure)|(AttributeDescriptor)|(DataAttribute)|(GroupDimensionDescriptor)|(DimensionDescriptor)|(Dimension)|(TimeDimension)|(MeasureDescriptor)|(Measure)|(Dataflow)))|(categoryscheme\\.((Any)|(CategoryScheme)|(Category)|(Categorisation)|(ReportingTaxonomy)|(ReportingCategory)))|(registry\\.((Any)|(ProvisionAgreement)|(MetadataProvisionAgreement)|(DataConstraint)|(MetadataConstraint)|(Subscription)))|(metadatastructure\\.((Any)|(MetadataAttributeDescriptor)|(MetadataAttribute)|(MetadataStructure)|(Metadataflow)))|(process\\.((Any)|(Process)|(ProcessStep)|(Transition)))|(structuremapping\\.((Any)|(StructureMap)|(ComponentMap)|(EpochMap)|(DatePatternMap)|(ConceptSchemeMap)|(OrganisationSchemeMap)|(CategorySchemeMap)|(ReportingTaxonomyMap)|(RepresentationMap)|(FrequencyFormatMapping)))|(transformation\\.((Any)|(TransformationScheme)|(Transformation)|(CustomTypeScheme)|(CustomType)|(NamePersonalisationScheme)|(NamePersonalisation)|(VtlMappingScheme)|(VtlCodelistMapping)|(VtlConceptMapping)|(VtlDataflowMapping)|(RulesetScheme)|(Ruleset)|(UserDefinedOperatorScheme)|(UserDefinedOperator))))=(([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*)|(\\*)):(([A-Za-z0-9_@$-]+)|(\\*))\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+))|(\\*))\\)((((\\.[A-Za-z0-9_@$-]+)*)|(\\.\\*))(((\\.[A-Za-z0-9_@$-]+)*)|(\\.\\*)))?$"
		},
		"DataStructureReferenceType":{
			"description":"DataStructureReferenceType is a type for referencing a data structure definition object. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.datastructure\\.DataStructure=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)$"
		},
		"DataflowReferenceType":{
			"description":"DataflowReferenceType is a type for referencing a dataflow object. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.datastructure\\.Dataflow=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)$"
		},
		"ProvisionAgreementReferenceType":{
			"description":"ProvisionAgreementReferenceType is a type for referencing a provision agreement. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.registry\\.ProvisionAgreement=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)$"
		},
		"DataProviderReferenceType":{
			"description":"DataProviderReferenceType is a type for referencing a data provider. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.base\\.DataProvider=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):DATA_PROVIDERS\\(1\\.0\\)(\\.[A-Za-z0-9_@$-]+)$"
		},
		"MetadataProviderReferenceType":{
			"description":"MetadataProviderReferenceType is a type for referencing a metadata provider. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.base\\.MetadataProvider=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):METADATA_PROVIDERS\\(1\\.0\\)(\\.[A-Za-z0-9_@$-]+)$"
		},
		"MetadataStructureReferenceType":{
			"description":"MetadataStructureReferenceType is a type for referencing a metadata structure definition object. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.metadatastructure\\.MetadataStructure=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)$"
		},
		"MetadataflowReferenceType":{
			"description":"MetadataflowReferenceType is a type for referencing a metadata flow object. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.metadatastructure\\.Metadataflow=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)$"
		},
		"MetadataProvisionAgreementReferenceType":{
			"description":"MetadataProvisionAgreementReferenceType is a type for referencing a metadata provision agreement. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.registry\\.MetadataProvisionAgreement=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)$"
		},
		"MetadataSetReferenceType":{
			"description":"MetadataSetReferenceType is a type for referencing a metadata set. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.metadatastructure\\.MetadataSet=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)$"
		},
		"MetadataAttributeReferenceType":{
			"description":"MetadataAttributeReferenceType is a type for referencing a metadata attribute object in a metadata structur. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.metadatastructure\\.MetadataAttribute=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)(\\.[A-Za-z0-9_@$-]+(\\.[A-Za-z0-9_@$-]+)*)$"
		},
		"StructureUsageReferenceType":{
			"description":"StructureUsageReferenceType is a specific type of MaintainableReference that is used for referencing any structure usages. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.((datastructure\\.Dataflow)|(metadatastructure\\.Metadataflow))=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)$"
		},
		"StructureOrUsageReferenceType":{
			"description":"StructureOrUsageReferenceType is a specific type of a reference for referencing either a structure or a structure usage. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.((datastructure\\.((DataStructure)|(Dataflow)))|(metadatastructure\\.((MetadataStructure)|(Metadataflow))))=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)$"
		},
		"StructureReferenceType":{
			"description":"StructureReferenceType is a specific type of MaintainableReference that is used for referencing any structure. It consists of a URN and/or a complete set of reference fields; agency, id, and version.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.((datastructure\\.DataStructure)|(metadatastructure\\.MetadataStructure))=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)$"
		},
		"CategorySchemeReferenceType":{
			"description":"CategorySchemeReferenceType is a type for referencing a category scheme object. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.categoryscheme\\.CategoryScheme=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)$"
		},
		"CategoryReferenceType":{
			"description":"CategoryReferenceType is a type for referencing a category object. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.categoryscheme\\.Category=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)(\\.[A-Za-z0-9_@$-]+(\\.[A-Za-z0-9_@$-]+)*)$"
		},
		"ConceptSchemeReferenceType":{
			"description":"ConceptSchemeReferenceType is a type for referencing a concept scheme object. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.conceptscheme\\.ConceptScheme=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)$"
		},
		"ConceptReferenceType":{
			"description":"ConceptReferenceType is a type for referencing a concept object. It consists of a URN",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.conceptscheme\\.Concept=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)(\\.[A-Za-z0-9_@$-]+)$"
		},
		"CodelistReferenceType":{
			"description":"CodelistReferenceType is a type for referencing a codelist object. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.codelist\\.Codelist=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)$"
		},
		"AnyCodelistReferenceType":{
			"description":"AnyCodelistReferenceType is a type for referencing a codelist or valuelist object. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.codelist\\.((Codelist)|(ValueList))=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)$"
		},
		"CodeReferenceType":{
			"description":"CodeReferenceType is a type for referencing a code object. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.codelist\\.Code=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)(\\.[A-Za-z0-9_@$-]+)$"
		},
		"EnumerationReferenceType":{
			"description":"EnumerationReferenceType is a specific type of MaintainableReference that is used for referencing item schemes or a value list. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.((base\\.((OrganisationUnitScheme)|(AgencyScheme)|(DataProviderScheme)|(MetadataProviderScheme)|(DataConsumerScheme)))|(codelist\\.((Codelist)|(Valuelist)|(Hierarchy)))|(conceptscheme\\.((ConceptScheme)))|(categoryscheme\\.((CategoryScheme)|(ReportingTaxonomy))))=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)$"
		},
		"HierarchyReferenceType":{
			"description":"HierarchyReferenceType is a type for referencing a hierarchy object. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.codelist\\.Hierarchy=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)$"
		},
		"OrganisationSchemeReferenceType":{
			"description":"OrganisationSchemeReferenceType references an organisation scheme regardless of the specific type. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.((base\\.((AgencyScheme)|(DataConsumerScheme)|(DataProviderScheme)|(MetadataProviderScheme)|(OrganisationUnitScheme))))=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)$"
		},
		"ReportingTaxonomyReferenceType":{
			"description":"ReportingTaxonomyReferenceType is a type for referencing a reporting taxonomy object. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.categoryscheme\\.ReportingTaxonomy=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)$"
		},
		"FrequencyFormatMappingReferenceType":{
			"description":"FrequencyFormatMappingReferenceType is a type for referencing a frequency format mapping object. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.structuremapping\\.FrequencyFormatMapping=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)(\\.[A-Za-z0-9_@$-]+)$"
		},
		"RepresentationMapReferenceType":{
			"description":"RepresentationMapReferenceType is a type for referencing a representation map object. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.structuremapping\\.RepresentationMap=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)$"
		},
		"RulesetSchemeReferenceType":{
			"description":"RulesetSchemeReferenceType is a type for referencing a ruleset scheme object. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.transformation\\.RulesetScheme=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)$"
		},
		"NamePersonalisationSchemeReferenceType":{
			"description":"NamePersonalisationSchemeReferenceType is a type for referencing a name personalisation scheme object. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.transformation\\.NamePersonalisationScheme=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)$"
		},
		"CustomTypeSchemeReferenceType":{
			"description":"CustomTypeSchemeReferenceType is a type for referencing a custom type scheme object. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.transformation\\.CustomTypeScheme=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)$"
		},
		"UserDefinedOperatorSchemeReferenceType":{
			"description":"UserDefinedOperatorSchemeReferenceType is a type for referencing a user defined operator scheme object. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.transformation\\.UserDefinedOperatorScheme=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)$"
		},
		"VtlMappingSchemeReferenceType":{
			"description":"VtlMappingSchemeReferenceType is a type for referencing a VTL mapping scheme object. It consists of a URN.",
			"type":"string",
			"pattern":"^urn:sdmx:org\\.sdmx\\.infomodel\\.transformation\\.VtlMappingScheme=([A-Za-z][A-Za-z0-9_-]*(\\.[A-Za-z][A-Za-z0-9_-]*)*):([A-Za-z0-9_@$-]+)\\((((0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?)|((0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){2}(-(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*))(\\.(([A-Za-z-]|([A-Za-z-][A-Za-z0-9-]+)|([A-Za-z0-9-]+[A-Za-z-][A-Za-z0-9-]*))|(0|[1-9][0-9]*)))*)?)|(((0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+\\.(0|[1-9]\\d*))|((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\+)))\\)$"
		},
		"duration":{
			"type":"string",
			"pattern":"^P((([0-9]+Y([0-9]+M)?([0-9]+D)?|([0-9]+M)([0-9]+D)?|([0-9]+D))(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S))))$"
		}
	}
}
